/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).
 */
#ifndef DENM_PDU_DESCRIPTIONS_H
#define DENM_PDU_DESCRIPTIONS_H

#include <stdio.h>
#include <stdlib.h>
#include "rtpersrc/asn1PerCppTypes.h"
#include "rtsrc/asn1CppTypes.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtsrc/asn1type.h"
#include "rtxmlsrc/asn1xml.h"
#include "rtxmlsrc/rtXmlCppMsgBuf.h"
#include "rtsrc/asn1type.h"
#include "rtjsonsrc/asn1json.h"
#include "rtjsonsrc/rtJsonCppMsgBuf.h"

#include "rtsrc/ASN1CSeqOfList.h"
#include "ITS-Container.h"

/**
 * Header file for ASN.1 module DENM-PDU-Descriptions
 */
/**************************************************************/
/*                                                            */
/*  Termination                                               */
/*                                                            */
/**************************************************************/
/*
Termination ::= ENUMERATED { isCancellation(0), isNegation(1) }
*/
struct EXTERN Termination {
   enum Root {
      isCancellation = 0,
      isNegation = 1
   } ;
} ;

typedef OSUINT32 ASN1T_Termination;

EXTERN int asn1PE_Termination (OSCTXT* pctxt, ASN1T_Termination value);

EXTERN int asn1PD_Termination (OSCTXT* pctxt, ASN1T_Termination* pvalue);

EXTERN int XmlEnc_Termination (OSCTXT* pctxt, ASN1T_Termination value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Termination (OSCTXT* pctxt, ASN1T_Termination* pvalue);

EXTERN int asn1JsonEnc_Termination (OSCTXT *pctxt, ASN1T_Termination *pvalue);

EXTERN int asn1JsonDec_Termination (OSCTXT *pctxt, ASN1T_Termination *pvalue);

EXTERN int asn1PrtToStrm_Termination (OSCTXT *pctxt, 
   const char* name, const ASN1T_Termination* pvalue);

EXTERN ASN1T_Termination* new_ASN1T_Termination (ASN1CType& ccobj);

EXTERN extern const OSEnumItem ASN1T_Termination_ENUMTAB[];
#define ASN1T_Termination_ENUMTABSIZE 2

EXTERN const OSUTF8CHAR* ASN1T_Termination_ToString (OSINT32 value);

EXTERN int ASN1T_Termination_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_Termination* pvalue);

EXTERN int ASN1T_Termination_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_Termination* pvalue);

/**************************************************************/
/*                                                            */
/*  ManagementContainer                                       */
/*                                                            */
/**************************************************************/
/*
ManagementContainer ::= SEQUENCE {
   actionID [0] ActionID,
   detectionTime [1] TimestampIts,
   referenceTime [2] TimestampIts,
   termination [3] Termination OPTIONAL,
   eventPosition [4] ReferencePosition,
   relevanceDistance [5] RelevanceDistance OPTIONAL,
   relevanceTrafficDirection [6] RelevanceTrafficDirection OPTIONAL,
   validityDuration [7] ValidityDuration OPTIONAL,
   transmissionInterval [8] TransmissionInterval OPTIONAL,
   stationType [9] StationType,
   ...
}
*/
struct EXTERN ASN1T_ManagementContainer {
   struct {
      unsigned terminationPresent : 1;
      unsigned relevanceDistancePresent : 1;
      unsigned relevanceTrafficDirectionPresent : 1;
      unsigned validityDurationPresent : 1;
      unsigned transmissionIntervalPresent : 1;
   } m;
   ASN1T_ITS_ActionID actionID;
   ASN1T_ITS_TimestampIts detectionTime;
   ASN1T_ITS_TimestampIts referenceTime;
   ASN1T_Termination termination;
   ASN1T_ITS_ReferencePosition eventPosition;
   ASN1T_ITS_RelevanceDistance relevanceDistance;
   ASN1T_ITS_RelevanceTrafficDirection relevanceTrafficDirection;
   ASN1T_ITS_ValidityDuration validityDuration;
   ASN1T_ITS_TransmissionInterval transmissionInterval;
   ASN1T_ITS_StationType stationType;
   ASN1TSeqExt extElem1;
   ASN1T_ManagementContainer ();
} ;

EXTERN int asn1PE_ManagementContainer (OSCTXT* pctxt, ASN1T_ManagementContainer* pvalue);

EXTERN int asn1PD_ManagementContainer (OSCTXT* pctxt, ASN1T_ManagementContainer* pvalue);

EXTERN int XmlEnc_ManagementContainer (OSCTXT* pctxt, 
   ASN1T_ManagementContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ManagementContainer (OSCTXT* pctxt, 
   ASN1T_ManagementContainer* pvalue);

EXTERN int asn1JsonEnc_ManagementContainer (OSCTXT *pctxt, ASN1T_ManagementContainer *pvalue);

EXTERN int asn1JsonDec_ManagementContainer (OSCTXT *pctxt, ASN1T_ManagementContainer *pvalue);

EXTERN int asn1PrtToStrm_ManagementContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_ManagementContainer* pvalue);

EXTERN ASN1T_ManagementContainer* 
   new_ASN1T_ManagementContainer (ASN1CType& ccobj);

EXTERN int asn1Init_ManagementContainer (ASN1T_ManagementContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ManagementContainer (OSCTXT *pctxt, 
   ASN1T_ManagementContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  SituationContainer                                        */
/*                                                            */
/**************************************************************/
/*
SituationContainer ::= SEQUENCE {
   informationQuality [0] InformationQuality,
   eventType [1] CauseCode,
   linkedCause [2] CauseCode OPTIONAL,
   eventHistory [3] EventHistory OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_SituationContainer {
   struct {
      unsigned linkedCausePresent : 1;
      unsigned eventHistoryPresent : 1;
   } m;
   ASN1T_ITS_InformationQuality informationQuality;
   ASN1T_ITS_CauseCode eventType;
   ASN1T_ITS_CauseCode linkedCause;
   ASN1T_ITS_EventHistory eventHistory;
   ASN1TSeqExt extElem1;
   ASN1T_SituationContainer ();
} ;

EXTERN int asn1PE_SituationContainer (OSCTXT* pctxt, ASN1T_SituationContainer* pvalue);

EXTERN int asn1PD_SituationContainer (OSCTXT* pctxt, ASN1T_SituationContainer* pvalue);

EXTERN int XmlEnc_SituationContainer (OSCTXT* pctxt, 
   ASN1T_SituationContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SituationContainer (OSCTXT* pctxt, 
   ASN1T_SituationContainer* pvalue);

EXTERN int asn1JsonEnc_SituationContainer (OSCTXT *pctxt, ASN1T_SituationContainer *pvalue);

EXTERN int asn1JsonDec_SituationContainer (OSCTXT *pctxt, ASN1T_SituationContainer *pvalue);

EXTERN int asn1PrtToStrm_SituationContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_SituationContainer* pvalue);

EXTERN ASN1T_SituationContainer* 
   new_ASN1T_SituationContainer (ASN1CType& ccobj);

EXTERN int asn1Init_SituationContainer (ASN1T_SituationContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_SituationContainer (OSCTXT *pctxt, 
   ASN1T_SituationContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  LocationContainer                                         */
/*                                                            */
/**************************************************************/
/*
LocationContainer ::= SEQUENCE {
   eventSpeed [0] Speed OPTIONAL,
   eventPositionHeading [1] Heading OPTIONAL,
   traces [2] Traces,
   roadType [3] RoadType OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_LocationContainer {
   struct {
      unsigned eventSpeedPresent : 1;
      unsigned eventPositionHeadingPresent : 1;
      unsigned roadTypePresent : 1;
   } m;
   ASN1T_ITS_Speed eventSpeed;
   ASN1T_ITS_Heading eventPositionHeading;
   ASN1T_ITS_Traces traces;
   ASN1T_ITS_RoadType roadType;
   ASN1TSeqExt extElem1;
   ASN1T_LocationContainer ();
} ;

EXTERN int asn1PE_LocationContainer (OSCTXT* pctxt, ASN1T_LocationContainer* pvalue);

EXTERN int asn1PD_LocationContainer (OSCTXT* pctxt, ASN1T_LocationContainer* pvalue);

EXTERN int XmlEnc_LocationContainer (OSCTXT* pctxt, 
   ASN1T_LocationContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LocationContainer (OSCTXT* pctxt, 
   ASN1T_LocationContainer* pvalue);

EXTERN int asn1JsonEnc_LocationContainer (OSCTXT *pctxt, ASN1T_LocationContainer *pvalue);

EXTERN int asn1JsonDec_LocationContainer (OSCTXT *pctxt, ASN1T_LocationContainer *pvalue);

EXTERN int asn1PrtToStrm_LocationContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_LocationContainer* pvalue);

EXTERN ASN1T_LocationContainer* new_ASN1T_LocationContainer (ASN1CType& ccobj)
   ;

EXTERN int asn1Init_LocationContainer (ASN1T_LocationContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_LocationContainer (OSCTXT *pctxt, 
   ASN1T_LocationContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  ImpactReductionContainer                                  */
/*                                                            */
/**************************************************************/
/*
ImpactReductionContainer ::= SEQUENCE {
   heightLonCarrLeft [0] HeightLonCarr,
   heightLonCarrRight [1] HeightLonCarr,
   posLonCarrLeft [2] PosLonCarr,
   posLonCarrRight [3] PosLonCarr,
   positionOfPillars [4] PositionOfPillars,
   posCentMass [5] PosCentMass,
   wheelBaseVehicle [6] WheelBaseVehicle,
   turningRadius [7] TurningRadius,
   posFrontAx [8] PosFrontAx,
   positionOfOccupants [9] PositionOfOccupants,
   vehicleMass [10] VehicleMass,
   requestResponseIndication [11] RequestResponseIndication
}
*/
struct EXTERN ASN1T_ImpactReductionContainer {
   ASN1T_ITS_HeightLonCarr heightLonCarrLeft;
   ASN1T_ITS_HeightLonCarr heightLonCarrRight;
   ASN1T_ITS_PosLonCarr posLonCarrLeft;
   ASN1T_ITS_PosLonCarr posLonCarrRight;
   ASN1T_ITS_PositionOfPillars positionOfPillars;
   ASN1T_ITS_PosCentMass posCentMass;
   ASN1T_ITS_WheelBaseVehicle wheelBaseVehicle;
   ASN1T_ITS_TurningRadius turningRadius;
   ASN1T_ITS_PosFrontAx posFrontAx;
   ASN1T_ITS_PositionOfOccupants positionOfOccupants;
   ASN1T_ITS_VehicleMass vehicleMass;
   ASN1T_ITS_RequestResponseIndication requestResponseIndication;
   ASN1T_ImpactReductionContainer ();
} ;

EXTERN int asn1PE_ImpactReductionContainer (OSCTXT* pctxt, ASN1T_ImpactReductionContainer* pvalue);

EXTERN int asn1PD_ImpactReductionContainer (OSCTXT* pctxt, ASN1T_ImpactReductionContainer* pvalue);

EXTERN int XmlEnc_ImpactReductionContainer (OSCTXT* pctxt, 
   ASN1T_ImpactReductionContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ImpactReductionContainer (OSCTXT* pctxt, 
   ASN1T_ImpactReductionContainer* pvalue);

EXTERN int asn1JsonEnc_ImpactReductionContainer (OSCTXT *pctxt, ASN1T_ImpactReductionContainer *pvalue);

EXTERN int asn1JsonDec_ImpactReductionContainer (OSCTXT *pctxt, ASN1T_ImpactReductionContainer *pvalue);

EXTERN int asn1PrtToStrm_ImpactReductionContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_ImpactReductionContainer* pvalue);

EXTERN ASN1T_ImpactReductionContainer* 
   new_ASN1T_ImpactReductionContainer (ASN1CType& ccobj);

EXTERN int asn1Init_ImpactReductionContainer (ASN1T_ImpactReductionContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ImpactReductionContainer (OSCTXT *pctxt, 
   ASN1T_ImpactReductionContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  ReferenceDenms                                            */
/*                                                            */
/**************************************************************/
/*
ReferenceDenms ::= SEQUENCE (SIZE (1..8, ...)) OF ActionID
*/
/* List of ASN1T_ITS_ActionID */
typedef ASN1TSeqOfList ASN1T_ReferenceDenms;

class EXTERN ASN1C_ReferenceDenms :
public ASN1CSeqOfList
{
protected:
   ASN1T_ReferenceDenms& msgData;
public:
   /**
    * Control class: ASN1C_ReferenceDenms
    * Data class:    ASN1T_ReferenceDenms
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_ReferenceDenms (ASN1T_ReferenceDenms& data);

   /**
    * Control class: ASN1C_ReferenceDenms<br/>
    * Data class: ASN1T_ReferenceDenms<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_ReferenceDenms (OSRTMessageBufferIF& msgBuf
      , ASN1T_ReferenceDenms& data);

   /**
    * Control class: ASN1C_ReferenceDenms<br/>
    * Data class: ASN1T_ReferenceDenms<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_ReferenceDenms (ASN1CType& ccobj, ASN1T_ReferenceDenms& data);

   virtual ~ASN1C_ReferenceDenms () {}

   /**
    * Data class: ASN1T_ITS_ActionID<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_ITS_ActionID* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_ITS_ActionID.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_ITS_ActionID* NewElement ();

   /**
    * Data class: ASN1T_ITS_ActionID.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_ITS_ActionID* AppendNewElement ();

private:
   ASN1C_ReferenceDenms& operator= (const ASN1C_ReferenceDenms&) {return *this;}
} ;

EXTERN int asn1PE_ReferenceDenms (OSCTXT* pctxt, ASN1T_ReferenceDenms* pvalue);

EXTERN int asn1PD_ReferenceDenms (OSCTXT* pctxt, ASN1T_ReferenceDenms* pvalue);

EXTERN int XmlEnc_ReferenceDenms (OSCTXT* pctxt, ASN1T_ReferenceDenms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ReferenceDenms (OSCTXT* pctxt, ASN1T_ReferenceDenms* pvalue)
   ;

EXTERN int asn1JsonEnc_ReferenceDenms (OSCTXT *pctxt, ASN1T_ReferenceDenms *pvalue);

EXTERN int asn1JsonDec_ReferenceDenms (OSCTXT *pctxt, ASN1T_ReferenceDenms *pvalue);

EXTERN int asn1PrtToStrm_ReferenceDenms (OSCTXT *pctxt, 
   const char* name, const ASN1T_ReferenceDenms* pvalue);

EXTERN int asn1Init_ReferenceDenms (ASN1T_ReferenceDenms* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ReferenceDenms (OSCTXT *pctxt, ASN1T_ReferenceDenms* pvalue);

/**************************************************************/
/*                                                            */
/*  RoadWorksContainerExtended                                */
/*                                                            */
/**************************************************************/
/*
RoadWorksContainerExtended ::= SEQUENCE {
   lightBarSirenInUse [0] LightBarSirenInUse OPTIONAL,
   closedLanes [1] ClosedLanes OPTIONAL,
   restriction [2] RestrictedTypes OPTIONAL,
   speedLimit [3] SpeedLimit OPTIONAL,
   incidentIndication [4] CauseCode OPTIONAL,
   recommendedPath [5] ItineraryPath OPTIONAL,
   startingPointSpeedLimit [6] DeltaReferencePosition OPTIONAL,
   trafficFlowRule [7] TrafficRule OPTIONAL,
   referenceDenms [8] ReferenceDenms OPTIONAL
}
*/
struct EXTERN ASN1T_RoadWorksContainerExtended {
   struct {
      unsigned lightBarSirenInUsePresent : 1;
      unsigned closedLanesPresent : 1;
      unsigned restrictionPresent : 1;
      unsigned speedLimitPresent : 1;
      unsigned incidentIndicationPresent : 1;
      unsigned recommendedPathPresent : 1;
      unsigned startingPointSpeedLimitPresent : 1;
      unsigned trafficFlowRulePresent : 1;
      unsigned referenceDenmsPresent : 1;
   } m;
   ASN1T_ITS_LightBarSirenInUse lightBarSirenInUse;
   ASN1T_ITS_ClosedLanes closedLanes;
   ASN1T_ITS_RestrictedTypes restriction;
   ASN1T_ITS_SpeedLimit speedLimit;
   ASN1T_ITS_CauseCode incidentIndication;
   ASN1T_ITS_ItineraryPath recommendedPath;
   ASN1T_ITS_DeltaReferencePosition startingPointSpeedLimit;
   ASN1T_ITS_TrafficRule trafficFlowRule;
   ASN1T_ReferenceDenms referenceDenms;
   ASN1T_RoadWorksContainerExtended ();
} ;

EXTERN int asn1PE_RoadWorksContainerExtended (OSCTXT* pctxt, ASN1T_RoadWorksContainerExtended* pvalue);

EXTERN int asn1PD_RoadWorksContainerExtended (OSCTXT* pctxt, ASN1T_RoadWorksContainerExtended* pvalue);

EXTERN int XmlEnc_RoadWorksContainerExtended (OSCTXT* pctxt, 
   ASN1T_RoadWorksContainerExtended* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_RoadWorksContainerExtended (OSCTXT* pctxt, 
   ASN1T_RoadWorksContainerExtended* pvalue);

EXTERN int asn1JsonEnc_RoadWorksContainerExtended (OSCTXT *pctxt, ASN1T_RoadWorksContainerExtended *pvalue);

EXTERN int asn1JsonDec_RoadWorksContainerExtended (OSCTXT *pctxt, ASN1T_RoadWorksContainerExtended *pvalue);

EXTERN int asn1PrtToStrm_RoadWorksContainerExtended (OSCTXT *pctxt, 
   const char* name, const ASN1T_RoadWorksContainerExtended* pvalue);

EXTERN ASN1T_RoadWorksContainerExtended* 
   new_ASN1T_RoadWorksContainerExtended (ASN1CType& ccobj);

EXTERN int asn1Init_RoadWorksContainerExtended (
   ASN1T_RoadWorksContainerExtended* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_RoadWorksContainerExtended (OSCTXT *pctxt, 
   ASN1T_RoadWorksContainerExtended* pvalue);

/**************************************************************/
/*                                                            */
/*  StationaryVehicleContainer                                */
/*                                                            */
/**************************************************************/
/*
StationaryVehicleContainer ::= SEQUENCE {
   stationarySince [0] StationarySince OPTIONAL,
   stationaryCause [1] CauseCode OPTIONAL,
   carryingDangerousGoods [2] DangerousGoodsExtended OPTIONAL,
   numberOfOccupants [3] NumberOfOccupants OPTIONAL,
   vehicleIdentification [4] VehicleIdentification OPTIONAL,
   energyStorageType [5] EnergyStorageType OPTIONAL
}
*/
struct EXTERN ASN1T_StationaryVehicleContainer {
   struct {
      unsigned stationarySincePresent : 1;
      unsigned stationaryCausePresent : 1;
      unsigned carryingDangerousGoodsPresent : 1;
      unsigned numberOfOccupantsPresent : 1;
      unsigned vehicleIdentificationPresent : 1;
      unsigned energyStorageTypePresent : 1;
   } m;
   ASN1T_ITS_StationarySince stationarySince;
   ASN1T_ITS_CauseCode stationaryCause;
   ASN1T_ITS_DangerousGoodsExtended carryingDangerousGoods;
   ASN1T_ITS_NumberOfOccupants numberOfOccupants;
   ASN1T_ITS_VehicleIdentification vehicleIdentification;
   ASN1T_ITS_EnergyStorageType energyStorageType;
   ASN1T_StationaryVehicleContainer ();
} ;

EXTERN int asn1PE_StationaryVehicleContainer (OSCTXT* pctxt, ASN1T_StationaryVehicleContainer* pvalue);

EXTERN int asn1PD_StationaryVehicleContainer (OSCTXT* pctxt, ASN1T_StationaryVehicleContainer* pvalue);

EXTERN int XmlEnc_StationaryVehicleContainer (OSCTXT* pctxt, 
   ASN1T_StationaryVehicleContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_StationaryVehicleContainer (OSCTXT* pctxt, 
   ASN1T_StationaryVehicleContainer* pvalue);

EXTERN int asn1JsonEnc_StationaryVehicleContainer (OSCTXT *pctxt, ASN1T_StationaryVehicleContainer *pvalue);

EXTERN int asn1JsonDec_StationaryVehicleContainer (OSCTXT *pctxt, ASN1T_StationaryVehicleContainer *pvalue);

EXTERN int asn1PrtToStrm_StationaryVehicleContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_StationaryVehicleContainer* pvalue);

EXTERN ASN1T_StationaryVehicleContainer* 
   new_ASN1T_StationaryVehicleContainer (ASN1CType& ccobj);

EXTERN int asn1Init_StationaryVehicleContainer (
   ASN1T_StationaryVehicleContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_StationaryVehicleContainer (OSCTXT *pctxt, 
   ASN1T_StationaryVehicleContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  AlacarteContainer                                         */
/*                                                            */
/**************************************************************/
/*
AlacarteContainer ::= SEQUENCE {
   lanePosition [0] LanePosition OPTIONAL,
   impactReduction [1] ImpactReductionContainer OPTIONAL,
   externalTemperature [2] Temperature OPTIONAL,
   roadWorks [3] RoadWorksContainerExtended OPTIONAL,
   positioningSolution [4] PositioningSolutionType OPTIONAL,
   stationaryVehicle [5] StationaryVehicleContainer OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_AlacarteContainer {
   struct {
      unsigned lanePositionPresent : 1;
      unsigned impactReductionPresent : 1;
      unsigned externalTemperaturePresent : 1;
      unsigned roadWorksPresent : 1;
      unsigned positioningSolutionPresent : 1;
      unsigned stationaryVehiclePresent : 1;
   } m;
   ASN1T_ITS_LanePosition lanePosition;
   ASN1T_ImpactReductionContainer impactReduction;
   ASN1T_ITS_Temperature externalTemperature;
   ASN1T_RoadWorksContainerExtended roadWorks;
   ASN1T_ITS_PositioningSolutionType positioningSolution;
   ASN1T_StationaryVehicleContainer stationaryVehicle;
   ASN1TSeqExt extElem1;
   ASN1T_AlacarteContainer ();
} ;

EXTERN int asn1PE_AlacarteContainer (OSCTXT* pctxt, ASN1T_AlacarteContainer* pvalue);

EXTERN int asn1PD_AlacarteContainer (OSCTXT* pctxt, ASN1T_AlacarteContainer* pvalue);

EXTERN int XmlEnc_AlacarteContainer (OSCTXT* pctxt, 
   ASN1T_AlacarteContainer* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AlacarteContainer (OSCTXT* pctxt, 
   ASN1T_AlacarteContainer* pvalue);

EXTERN int asn1JsonEnc_AlacarteContainer (OSCTXT *pctxt, ASN1T_AlacarteContainer *pvalue);

EXTERN int asn1JsonDec_AlacarteContainer (OSCTXT *pctxt, ASN1T_AlacarteContainer *pvalue);

EXTERN int asn1PrtToStrm_AlacarteContainer (OSCTXT *pctxt, 
   const char* name, const ASN1T_AlacarteContainer* pvalue);

EXTERN ASN1T_AlacarteContainer* new_ASN1T_AlacarteContainer (ASN1CType& ccobj)
   ;

EXTERN int asn1Init_AlacarteContainer (ASN1T_AlacarteContainer* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_AlacarteContainer (OSCTXT *pctxt, 
   ASN1T_AlacarteContainer* pvalue);

/**************************************************************/
/*                                                            */
/*  DecentralizedEnvironmentalNotificationMessage             */
/*                                                            */
/**************************************************************/
/*
DecentralizedEnvironmentalNotificationMessage ::= SEQUENCE {
   management [0] ManagementContainer,
   situation [1] SituationContainer OPTIONAL,
   location [2] LocationContainer OPTIONAL,
   alacarte [3] AlacarteContainer OPTIONAL
}
*/
struct EXTERN ASN1T_DecentralizedEnvironmentalNotificationMessage {
   struct {
      unsigned situationPresent : 1;
      unsigned locationPresent : 1;
      unsigned alacartePresent : 1;
   } m;
   ASN1T_ManagementContainer management;
   ASN1T_SituationContainer situation;
   ASN1T_LocationContainer location;
   ASN1T_AlacarteContainer alacarte;
   ASN1T_DecentralizedEnvironmentalNotificationMessage ();
} ;

EXTERN int asn1PE_DecentralizedEnvironmentalNotificationMessage (OSCTXT* pctxt, ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue);

EXTERN int asn1PD_DecentralizedEnvironmentalNotificationMessage (OSCTXT* pctxt, ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue);

EXTERN int XmlEnc_DecentralizedEnvironmentalNotificationMessage 
   (OSCTXT* pctxt, 
   ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_DecentralizedEnvironmentalNotificationMessage 
   (OSCTXT* pctxt, ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue)
   ;

EXTERN int asn1JsonEnc_DecentralizedEnvironmentalNotificationMessage (OSCTXT *pctxt, ASN1T_DecentralizedEnvironmentalNotificationMessage *pvalue);

EXTERN int asn1JsonDec_DecentralizedEnvironmentalNotificationMessage (OSCTXT *pctxt, ASN1T_DecentralizedEnvironmentalNotificationMessage *pvalue);

EXTERN int asn1PrtToStrm_DecentralizedEnvironmentalNotificationMessage (OSCTXT *pctxt, 
   const char* name, const ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue);

EXTERN ASN1T_DecentralizedEnvironmentalNotificationMessage* 
   new_ASN1T_DecentralizedEnvironmentalNotificationMessage (ASN1CType& ccobj);

EXTERN int asn1Init_DecentralizedEnvironmentalNotificationMessage (
   ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_DecentralizedEnvironmentalNotificationMessage (OSCTXT *pctxt, 
   ASN1T_DecentralizedEnvironmentalNotificationMessage* pvalue);

/**************************************************************/
/*                                                            */
/*  DENM                                                      */
/*                                                            */
/**************************************************************/
/*
DENM ::= SEQUENCE {
   header [0] ItsPduHeader,
   denm [1] DecentralizedEnvironmentalNotificationMessage
}
*/
struct EXTERN ASN1T_DENM : public ASN1TPDU {
   ASN1T_ITS_ItsPduHeader header;
   ASN1T_DecentralizedEnvironmentalNotificationMessage denm;
   ASN1T_DENM ();
   ~ASN1T_DENM ();
} ;

class EXTERN ASN1C_DENM :
public ASN1CType
{
protected:
   ASN1T_DENM& msgData;
public:
   /**
    * Control class: ASN1C_DENM
    * Data class:    ASN1T_DENM
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_DENM (ASN1T_DENM& data);

   /**
    * Control class: ASN1C_DENM<br/>
    * Data class: ASN1T_DENM<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_DENM (OSRTMessageBufferIF& msgBuf, ASN1T_DENM& data);

   virtual ~ASN1C_DENM () {}

   /**
    * Data class: ASN1T_DENM<br/>
    *
    * Gets a mutable instance of the data class.
    *
    * @return Reference to a mutable instance of data class ASN1T_DENM.
    */
   inline ASN1T_DENM& getData () { return msgData; }

   /**
    * Data class: ASN1T_DENM<br/>
    * Gets a non-mutable instance of the data class.
    *
    * @return Reference to a non-mutable instance of data class ASN1T_DENM.
    */
   inline const ASN1T_DENM& getData () const { return msgData; }

   // standard encode/decode methods (defined in ASN1CType base class):
   // int Encode ();
   // int Decode ();

   // stream encode/decode methods:
   /**
    * Encodes into a specified encode buffer.
    *
    * @param msgBuf Reference to an encode buffer.
    * @return A status value (0 indicates success).
    */
   int EncodeTo (OSRTMessageBufferIF& msgBuf);

   /**
    * Decodes from a specified decode buffer.
    *
    * @param msgBuf Reference to a decode buffer.
    * @return A status value (0 indicates success).
    */
   int DecodeFrom (OSRTMessageBufferIF& msgBuf, OSBOOL free = FALSE);

   /**
    * Frees the memory associated with the instance.
    */
   virtual void MemFree ();

   /**
    * Writes the contents of the object to a user-defined stream using
    * a user-defined print callback function.  See the documentation for
    * the setPrintStream() method.
    *
    * @param name A name for the object's contents.  If not specified,
    *             DENM will be used for the name.
    * @return Always returns 0.
    */
   int toStream (const char* name = "DENM");
   /**
    * Declares a print stream handler function.
    *
    * @param strmCallback Pointer to a function defined according to the
    *                     rtxPrintCallback signature.
    * @return A status value (0 indicates success).
    */
   int setPrintStream (rtxPrintCallback strmCallback, void* pStrmInfo);
private:
   ASN1C_DENM& operator= (const ASN1C_DENM&) {return *this;}
} ;

EXTERN int asn1PE_DENM (OSCTXT* pctxt, ASN1T_DENM* pvalue);

EXTERN int asn1PD_DENM (OSCTXT* pctxt, ASN1T_DENM* pvalue);

EXTERN int XmlEnc_DENM (OSCTXT* pctxt, ASN1T_DENM* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_DENM (OSCTXT* pctxt, ASN1T_DENM* pvalue);

EXTERN int asn1JsonEnc_DENM (OSCTXT *pctxt, ASN1T_DENM *pvalue);

EXTERN int asn1JsonDec_DENM (OSCTXT *pctxt, ASN1T_DENM *pvalue);

EXTERN int asn1PrtToStrm_DENM (OSCTXT *pctxt, 
   const char* name, const ASN1T_DENM* pvalue);

EXTERN ASN1T_DENM* new_ASN1T_DENM (ASN1CType& ccobj);

EXTERN int asn1Init_DENM (ASN1T_DENM* pvalue, OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_DENM (OSCTXT *pctxt, ASN1T_DENM* pvalue);

/**
 * Global element functions.  These functions encode or decode complete
 * XML documents.  They are generated for XSD global elements and/or
 * ASN.1 type definitions that are either:
 *
 * 1) not referenced by any other types, or
 * 2) explicitly declared to be a PDU using the -pdu command line
 *    option, or
 * 3) explicitly declared to be a PDU using the <isPDU/> 
 *    configuration file element.
 */
/* Value definitions */

#define ASN1V_defaultValidity 600

#endif
