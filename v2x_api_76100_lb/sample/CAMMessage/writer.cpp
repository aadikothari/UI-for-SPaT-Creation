/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).
 */
#include "CAM-PDU-Descriptions.h"

#include <stdio.h>
#include <stdlib.h>
#include "rtxsrc/rtxFile.h"
#include "rtxsrc/rtxPrint.h"

class ASN1C_CAM_Test : public ASN1C_CAM
{
public:
   ASN1C_CAM_Test (OSRTMessageBufferIF& msgBuf, ASN1T_CAM& data) :
      ASN1C_CAM(msgBuf, data) {}

   /**
    * Populates an instance of data class ASN1T_CAM with random test data.
    *
    * @param pctxt Pointer to an instance of the OSCTXT structure.
    * @return Pointer to an instance of data class ASN1T_CAM.
    */
   ASN1T_CAM* genTestInstance (OSCTXT* pctxt=0, OSBOOL free = FALSE);
} ;

int main (int argc, char** argv)
{
   int        i, stat;
   OSSIZE     len;
   OSBOOL     aligned = !TRUE;
   OSBOOL     trace = TRUE;
   OSBOOL     verbose = FALSE;
   const char* filename = "message.dat";
   const OSOCTET* msgptr;

   /* Process command line arguments */
   if (argc > 1) {
      for (i = 1; i < argc; i++) {
         if (!strcmp (argv[i], "-v")) verbose = TRUE;
         else if (!strcmp (argv[i], "-o")) filename = argv[++i];
         else if (!strcmp (argv[i], "-notrace")) trace = FALSE;
         else {
            printf ("usage: writer [-v] [-o <filename>]  [-notrace]\n");
            printf ("   -v  verbose mode: print trace info\n");
            printf ("   -o <filename>  write encoded msg to <filename>\n");
            printf ("   -notrace  do not display trace info\n");
            return 1;
         }
      }
   }

   /* Create an instance of the compiler generated class.
      This example uses a dynamic message buffer..*/
   ASN1PEREncodeBuffer encodeBuffer (aligned);
   ASN1T_CAM data;
   ASN1C_CAM_Test CAMPDU (encodeBuffer, data);

   // Populate structure of generated type
   CAMPDU.genTestInstance();

   /* Encode */
   encodeBuffer.setTrace (trace);
   encodeBuffer.setDiag (verbose);

   if ((stat = CAMPDU.Encode ()) == 0)
   {
      if (trace) {
         printf ("Encoding was successful\n");
         printf ("Hex dump of encoded record:\n");
         encodeBuffer.hexDump ();
         printf ("Binary dump:\n");
         encodeBuffer.binDump ("Data");
      }
      msgptr = encodeBuffer.getMsgPtr ();
      len = encodeBuffer.getMsgLen ();
   }
   else
   {
      printf ("Encoding failed\n");
      encodeBuffer.printErrorInfo ();
      return (-1);
   }
   /* Write the encoded message out to the output file */
   stat = rtxFileWriteBinary (filename, msgptr, len);
   if (stat < 0) {
      printf ("Write to file failed\n");
      encodeBuffer.printErrorInfo();
      return stat;
   }

   return 0;
}

ASN1T_CAM* ASN1C_CAM_Test::genTestInstance(OSCTXT *pctxt, OSBOOL free)
{
   if (0 == pctxt) pctxt = getCtxtPtr();
   ASN1T_CAM* pvalue = (ASN1T_CAM*)&msgData;
   asn1Init_CAM (pvalue, free, pctxt);

   pvalue->header.protocolVersion = 1;
   pvalue->header.messageID = 2;
   pvalue->header.stationID = 0;

   pvalue->cam.generationDeltaTime = 1;
   pvalue->cam.camParameters.basicContainer.stationType = 0;
   pvalue->cam.camParameters.basicContainer.referencePosition.latitude = 10;
   pvalue->cam.camParameters.basicContainer.referencePosition.longitude = 10;

   pvalue->cam.camParameters.basicContainer.referencePosition.
      positionConfidenceEllipse.semiMajorConfidence = 1;

   pvalue->cam.camParameters.basicContainer.referencePosition.
      positionConfidenceEllipse.semiMinorConfidence = 1;

   pvalue->cam.camParameters.basicContainer.referencePosition.
      positionConfidenceEllipse.semiMajorOrientation = 0;

   pvalue->cam.camParameters.basicContainer.referencePosition.
      altitude.altitudeValue = 0;

   pvalue->cam.camParameters.basicContainer.referencePosition.
      altitude.altitudeConfidence = ITS_AltitudeConfidence::alt_000_01;

   pvalue->cam.camParameters.highFrequencyContainer.t =  2;
   pvalue->cam.camParameters.highFrequencyContainer.u.
      rsuContainerHighFrequency = 
      rtxMemAllocTypeZ (pctxt, ASN1T_RSUContainerHighFrequency);

   pvalue->cam.camParameters.highFrequencyContainer.u.
      rsuContainerHighFrequency->m.protectedCommunicationZonesRSUPresent = 1;
   {
      ASN1C_ITS_ProtectedCommunicationZonesRSU llist6 
         (*this, pvalue->cam.camParameters.highFrequencyContainer.u.
          rsuContainerHighFrequency->protectedCommunicationZonesRSU);
      llist6.init ();
      ASN1T_ITS_ProtectedCommunicationZone* pdata;

      pdata = llist6.NewElement ();

      pdata->protectedZoneType = ITS_ProtectedZoneType::temporaryCenDsrcTolling;

      pdata->m.expiryTimePresent = 1;
      pdata->expiryTime = OSUI64CONST(3356619374592);

      pdata->protectedZoneLatitude = -899977995;

      pdata->protectedZoneLongitude = -1799997372;

      pdata->m.protectedZoneRadiusPresent = 1;
      pdata->protectedZoneRadius = 73;

      pdata->m.protectedZoneIDPresent = 1;
      pdata->protectedZoneID = 31062;

      llist6.Append (pdata);
   }

   pvalue->cam.camParameters.m.lowFrequencyContainerPresent = 1;
   pvalue->cam.camParameters.lowFrequencyContainer.t =  1;
   pvalue->cam.camParameters.lowFrequencyContainer.u.
      basicVehicleContainerLowFrequency = 
      rtxMemAllocTypeZ (pctxt, ASN1T_BasicVehicleContainerLowFrequency);

   pvalue->cam.camParameters.lowFrequencyContainer.u.
      basicVehicleContainerLowFrequency->vehicleRole = 
      ITS_VehicleRole::default_;

   pvalue->cam.camParameters.lowFrequencyContainer.u.
      basicVehicleContainerLowFrequency->exteriorLights.data[0] = 0x46;

   /* zero elements */

   pvalue->cam.camParameters.m.specialVehicleContainerPresent = 1;
   pvalue->cam.camParameters.specialVehicleContainer.t =  5;
   pvalue->cam.camParameters.specialVehicleContainer.u.rescueContainer = 
      rtxMemAllocTypeZ (pctxt, ASN1T_RescueContainer);

   pvalue->cam.camParameters.specialVehicleContainer.u.rescueContainer->
      lightBarSirenInUse.data[0] = 0x30;

   return (pvalue);
}
