/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).
 */
#ifndef SPAT_H
#define SPAT_H

#include <stdio.h>
#include <stdlib.h>
#include "rtpersrc/asn1PerCppTypes.h"
#include "rtsrc/asn1CppTypes.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtsrc/asn1type.h"
#include "rtxmlsrc/asn1xml.h"
#include "rtxmlsrc/rtXmlCppMsgBuf.h"
#include "rtsrc/asn1type.h"
#include "rtjsonsrc/asn1json.h"
#include "rtjsonsrc/rtJsonCppMsgBuf.h"

#include "rtsrc/ASN1CBitStr.h"
#include "rtsrc/ASN1CSeqOfList.h"

/**
 * Header file for ASN.1 module SPAT
 */
/**************************************************************/
/*                                                            */
/*  TimeIntervalConfidence                                    */
/*                                                            */
/**************************************************************/
/*
TimeIntervalConfidence ::= INTEGER (0..15)
    Value   Probability
      0         21%%
      1         36%%
      2         47%%
      3         56%%
      4         62%%
      5         68%%
      6         73%%
      7         77%%
      8         81%%
      9         85%%
      10        88%%
      11        91%%
      12        94%%
      13        96%%
      14        98%%
      15        100%%

*/
typedef OSUINT8 ASN1T_TimeIntervalConfidence;

EXTERN int asn1PE_TimeIntervalConfidence (OSCTXT* pctxt, ASN1T_TimeIntervalConfidence value);

EXTERN int asn1PD_TimeIntervalConfidence (OSCTXT* pctxt, ASN1T_TimeIntervalConfidence* pvalue);

EXTERN int XmlEnc_TimeIntervalConfidence (OSCTXT* pctxt, 
   ASN1T_TimeIntervalConfidence value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_TimeIntervalConfidence (OSCTXT* pctxt, 
   ASN1T_TimeIntervalConfidence* pvalue);

EXTERN int asn1JsonEnc_TimeIntervalConfidence (OSCTXT *pctxt, ASN1T_TimeIntervalConfidence *pvalue);

EXTERN int asn1JsonDec_TimeIntervalConfidence (OSCTXT *pctxt, ASN1T_TimeIntervalConfidence *pvalue);

EXTERN int asn1PrtToStrm_TimeIntervalConfidence (OSCTXT *pctxt, 
   const char* name, const ASN1T_TimeIntervalConfidence* pvalue);

EXTERN ASN1T_TimeIntervalConfidence* 
   new_ASN1T_TimeIntervalConfidence (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  IntersectionStatusObject                                  */
/*                                                            */
/**************************************************************/
/*
IntersectionStatusObject ::= BIT STRING  { manualControlIsEnabled(0), stopTimeIsActivated(1), failureFlash(2), preemptIsActive(3), signalPriorityIsActive(4), fixedTimeOperation(5), trafficDependentOperation(6), standbyOperation(7), failureMode(8), off(9), recentMAPmessageUpdate(10), recentChangeInMAPassignedLanesIDsUsed(11), noValidMAPisAvailableAtThisTime(12), noValidSPATisAvailableAtThisTime(13) } (SIZE (16))
*/
struct EXTERN ASN1T_IntersectionStatusObject {
   OSOCTET data[2];
   // ctors
   ASN1T_IntersectionStatusObject ()  {}
   ASN1T_IntersectionStatusObject (const OSOCTET* _data) {
      OSCRTLSAFEMEMCPY (data, 2, _data, 2);
   }
} ;

class EXTERN ASN1C_IntersectionStatusObject :
public ASN1CBitStr
{
protected:
   ASN1T_IntersectionStatusObject& msgData;
public:
   // named bits
   enum { manualControlIsEnabled = 0, stopTimeIsActivated = 1, failureFlash = 2, preemptIsActive = 3, signalPriorityIsActive = 4, fixedTimeOperation = 5, trafficDependentOperation = 6, standbyOperation = 7, failureMode = 8, off = 9, recentMAPmessageUpdate = 10, recentChangeInMAPassignedLanesIDsUsed = 11, noValidMAPisAvailableAtThisTime = 12, noValidSPATisAvailableAtThisTime = 13 };

   /**
    * Control class: ASN1C_IntersectionStatusObject
    * Data class:    ASN1T_IntersectionStatusObject
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_IntersectionStatusObject (ASN1T_IntersectionStatusObject& data);

   /**
    * Control class: ASN1C_IntersectionStatusObject<br/>
    * Data class: ASN1T_IntersectionStatusObject<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_IntersectionStatusObject (OSRTMessageBufferIF& msgBuf
      , ASN1T_IntersectionStatusObject& data);

   virtual ~ASN1C_IntersectionStatusObject () {}

private:
   ASN1C_IntersectionStatusObject& operator= (const ASN1C_IntersectionStatusObject&) {return *this;}
} ;

EXTERN int asn1PE_IntersectionStatusObject (OSCTXT* pctxt, ASN1T_IntersectionStatusObject* pvalue);

EXTERN int asn1PD_IntersectionStatusObject (OSCTXT* pctxt, ASN1T_IntersectionStatusObject* pvalue);

EXTERN int XmlEnc_IntersectionStatusObject (OSCTXT* pctxt, 
   ASN1T_IntersectionStatusObject* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_IntersectionStatusObject (OSCTXT* pctxt, 
   ASN1T_IntersectionStatusObject* pvalue);

EXTERN int asn1JsonEnc_IntersectionStatusObject (OSCTXT *pctxt, ASN1T_IntersectionStatusObject *pvalue);

EXTERN int asn1JsonDec_IntersectionStatusObject (OSCTXT *pctxt, ASN1T_IntersectionStatusObject *pvalue);

EXTERN int asn1PrtToStrm_IntersectionStatusObject (OSCTXT *pctxt, 
   const char* name, const ASN1T_IntersectionStatusObject* pvalue);

extern EXTERN struct OSBitMapItem g_ASN1T_IntersectionStatusObject_NAMEDBITTAB[15];

EXTERN ASN1T_IntersectionStatusObject* 
   new_ASN1T_IntersectionStatusObject (ASN1CType& ccobj);

EXTERN int asn1Init_IntersectionStatusObject (ASN1T_IntersectionStatusObject* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

/**************************************************************/
/*                                                            */
/*  EnabledLaneList                                           */
/*                                                            */
/**************************************************************/
/*
EnabledLaneList ::= SEQUENCE (SIZE (1..16)) OF LaneID
    The unique ID numbers for each
    lane object which is 'active' 
    as part of the dynamic map contents.

*/
typedef struct EXTERN ASN1T_EnabledLaneList {
   OSSIZE n;
   OSUINT8 *elem;
   ASN1T_EnabledLaneList () : n(0), elem(0) {}
} ASN1T_EnabledLaneList;

class EXTERN ASN1C_EnabledLaneList :
public ASN1CType
{
protected:
   ASN1T_EnabledLaneList& msgData;
public:
   /**
    * Control class: ASN1C_EnabledLaneList
    * Data class:    ASN1T_EnabledLaneList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_EnabledLaneList (ASN1T_EnabledLaneList& data);

   /**
    * Control class: ASN1C_EnabledLaneList<br/>
    * Data class: ASN1T_EnabledLaneList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_EnabledLaneList (OSRTMessageBufferIF& msgBuf
      , ASN1T_EnabledLaneList& data);

   /**
    * Control class: ASN1C_EnabledLaneList<br/>
    * Data class: ASN1T_EnabledLaneList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_EnabledLaneList (ASN1CType& ccobj, ASN1T_EnabledLaneList& data);

   virtual ~ASN1C_EnabledLaneList () {}

private:
   ASN1C_EnabledLaneList& operator= (const ASN1C_EnabledLaneList&) {return *this;}
} ;

EXTERN int asn1PE_EnabledLaneList (OSCTXT* pctxt, ASN1T_EnabledLaneList* pvalue);

EXTERN int asn1PD_EnabledLaneList (OSCTXT* pctxt, ASN1T_EnabledLaneList* pvalue);

EXTERN int XmlEnc_EnabledLaneList (OSCTXT* pctxt, 
   ASN1T_EnabledLaneList* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_EnabledLaneList (OSCTXT* pctxt, ASN1T_EnabledLaneList* pvalue
   );

EXTERN int asn1JsonEnc_EnabledLaneList (OSCTXT *pctxt, ASN1T_EnabledLaneList *pvalue);

EXTERN int asn1JsonDec_EnabledLaneList (OSCTXT *pctxt, ASN1T_EnabledLaneList *pvalue);

EXTERN int asn1PrtToStrm_EnabledLaneList (OSCTXT *pctxt, 
   const char* name, const ASN1T_EnabledLaneList* pvalue);

EXTERN int asn1Init_EnabledLaneList (ASN1T_EnabledLaneList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_EnabledLaneList (OSCTXT *pctxt, ASN1T_EnabledLaneList* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementPhaseState                                        */
/*                                                            */
/**************************************************************/
/*
MovementPhaseState ::= ENUMERATED { unavailable(0), dark(1), stop-Then-Proceed(2), stop-And-Remain(3), pre-Movement(4), permissive-Movement-Allowed(5), protected-Movement-Allowed(6), permissive-clearance(7), protected-clearance(8), caution-Conflicting-Traffic(9) }
     The above number assignments are not used with UPER encoding
     and are only to be used with DER or implicit encoding

*/
struct EXTERN MovementPhaseState {
   enum Root {
      unavailable = 0,
      dark = 1,
      stop_Then_Proceed = 2,
      stop_And_Remain = 3,
      pre_Movement = 4,
      permissive_Movement_Allowed = 5,
      protected_Movement_Allowed = 6,
      permissive_clearance = 7,
      protected_clearance = 8,
      caution_Conflicting_Traffic = 9
   } ;
} ;

typedef OSUINT32 ASN1T_MovementPhaseState;

EXTERN int asn1PE_MovementPhaseState (OSCTXT* pctxt, ASN1T_MovementPhaseState value);

EXTERN int asn1PD_MovementPhaseState (OSCTXT* pctxt, ASN1T_MovementPhaseState* pvalue);

EXTERN int XmlEnc_MovementPhaseState (OSCTXT* pctxt, 
   ASN1T_MovementPhaseState value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementPhaseState (OSCTXT* pctxt, 
   ASN1T_MovementPhaseState* pvalue);

EXTERN int asn1JsonEnc_MovementPhaseState (OSCTXT *pctxt, ASN1T_MovementPhaseState *pvalue);

EXTERN int asn1JsonDec_MovementPhaseState (OSCTXT *pctxt, ASN1T_MovementPhaseState *pvalue);

EXTERN int asn1PrtToStrm_MovementPhaseState (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementPhaseState* pvalue);

EXTERN ASN1T_MovementPhaseState* 
   new_ASN1T_MovementPhaseState (ASN1CType& ccobj);

EXTERN extern const OSEnumItem ASN1T_MovementPhaseState_ENUMTAB[];
#define ASN1T_MovementPhaseState_ENUMTABSIZE 10

EXTERN const OSUTF8CHAR* ASN1T_MovementPhaseState_ToString (OSINT32 value);

EXTERN int ASN1T_MovementPhaseState_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_MovementPhaseState* pvalue);

EXTERN int ASN1T_MovementPhaseState_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_MovementPhaseState* pvalue)
      ;

/**************************************************************/
/*                                                            */
/*  TimeMark                                                  */
/*                                                            */
/**************************************************************/
/*
TimeMark ::= INTEGER (0..36111)
    In units of 1/10th second from UTC time
    A range of 0~35999 covers one hour
    The values 36000..36009 are used when a leap second occurs
    The values 36010..36110 are reserved for future use
    36111 is to be used when the value is undefined or unknown
    Note that this is NOT expressed in GPS time
    or in local time

*/
typedef OSUINT16 ASN1T_SPAT_TimeMark;

EXTERN int asn1PE_SPAT_TimeMark (OSCTXT* pctxt, ASN1T_SPAT_TimeMark value);

EXTERN int asn1PD_SPAT_TimeMark (OSCTXT* pctxt, ASN1T_SPAT_TimeMark* pvalue);

EXTERN int XmlEnc_SPAT_TimeMark (OSCTXT* pctxt, ASN1T_SPAT_TimeMark value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SPAT_TimeMark (OSCTXT* pctxt, ASN1T_SPAT_TimeMark* pvalue);

EXTERN int asn1JsonEnc_SPAT_TimeMark (OSCTXT *pctxt, ASN1T_SPAT_TimeMark *pvalue);

EXTERN int asn1JsonDec_SPAT_TimeMark (OSCTXT *pctxt, ASN1T_SPAT_TimeMark *pvalue);

EXTERN int asn1PrtToStrm_SPAT_TimeMark (OSCTXT *pctxt, 
   const char* name, const ASN1T_SPAT_TimeMark* pvalue);

EXTERN ASN1T_SPAT_TimeMark* new_ASN1T_SPAT_TimeMark (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  TimeChangeDetails                                         */
/*                                                            */
/**************************************************************/
/*
TimeChangeDetails ::= SEQUENCE {
   startTime [0] TimeMark OPTIONAL,
               -- When this phase 1st started
   minEndTime [1] TimeMark,
               -- Expected shortest end time
   maxEndTime [2] TimeMark OPTIONAL,
               -- Expected longest end time
   likelyTime [3] TimeMark OPTIONAL,
               -- Best predicted value based on other data              
   confidence [4] TimeIntervalConfidence OPTIONAL,
               -- Applies to above time element only
   nextTime [5] TimeMark OPTIONAL
               -- A rough estimate of time when 
               -- this phase may next occur again
               -- used to support various ECO driving power 
               -- management needs.
}
*/
struct EXTERN ASN1T_TimeChangeDetails {
   struct {
      unsigned startTimePresent : 1;
      unsigned maxEndTimePresent : 1;
      unsigned likelyTimePresent : 1;
      unsigned confidencePresent : 1;
      unsigned nextTimePresent : 1;
   } m;
   ASN1T_SPAT_TimeMark startTime;
   ASN1T_SPAT_TimeMark minEndTime;
   ASN1T_SPAT_TimeMark maxEndTime;
   ASN1T_SPAT_TimeMark likelyTime;
   ASN1T_TimeIntervalConfidence confidence;
   ASN1T_SPAT_TimeMark nextTime;
   ASN1T_TimeChangeDetails ();
} ;

EXTERN int asn1PE_TimeChangeDetails (OSCTXT* pctxt, ASN1T_TimeChangeDetails* pvalue);

EXTERN int asn1PD_TimeChangeDetails (OSCTXT* pctxt, ASN1T_TimeChangeDetails* pvalue);

EXTERN int XmlEnc_TimeChangeDetails (OSCTXT* pctxt, 
   ASN1T_TimeChangeDetails* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_TimeChangeDetails (OSCTXT* pctxt, 
   ASN1T_TimeChangeDetails* pvalue);

EXTERN int asn1JsonEnc_TimeChangeDetails (OSCTXT *pctxt, ASN1T_TimeChangeDetails *pvalue);

EXTERN int asn1JsonDec_TimeChangeDetails (OSCTXT *pctxt, ASN1T_TimeChangeDetails *pvalue);

EXTERN int asn1PrtToStrm_TimeChangeDetails (OSCTXT *pctxt, 
   const char* name, const ASN1T_TimeChangeDetails* pvalue);

EXTERN ASN1T_TimeChangeDetails* new_ASN1T_TimeChangeDetails (ASN1CType& ccobj)
   ;

EXTERN int asn1Init_TimeChangeDetails (ASN1T_TimeChangeDetails* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

/**************************************************************/
/*                                                            */
/*  AdvisorySpeedType                                         */
/*                                                            */
/**************************************************************/
/*
AdvisorySpeedType ::= ENUMERATED { none(0), greenwave(1), ecoDrive(2), transit(3), ... }
       Note: subject to further growth

*/
struct EXTERN AdvisorySpeedType {
   enum Root {
      none = 0,
      greenwave = 1,
      ecoDrive = 2,
      transit = 3
   } ;
} ;

typedef OSUINT32 ASN1T_AdvisorySpeedType;

EXTERN int asn1PE_AdvisorySpeedType (OSCTXT* pctxt, ASN1T_AdvisorySpeedType value);

EXTERN int asn1PD_AdvisorySpeedType (OSCTXT* pctxt, ASN1T_AdvisorySpeedType* pvalue);

EXTERN int XmlEnc_AdvisorySpeedType (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeedType value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AdvisorySpeedType (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeedType* pvalue);

EXTERN int asn1JsonEnc_AdvisorySpeedType (OSCTXT *pctxt, ASN1T_AdvisorySpeedType *pvalue);

EXTERN int asn1JsonDec_AdvisorySpeedType (OSCTXT *pctxt, ASN1T_AdvisorySpeedType *pvalue);

EXTERN int asn1PrtToStrm_AdvisorySpeedType (OSCTXT *pctxt, 
   const char* name, const ASN1T_AdvisorySpeedType* pvalue);

EXTERN ASN1T_AdvisorySpeedType* new_ASN1T_AdvisorySpeedType (ASN1CType& ccobj)
   ;

EXTERN extern const OSEnumItem ASN1T_AdvisorySpeedType_ENUMTAB[];
#define ASN1T_AdvisorySpeedType_ENUMTABSIZE 4

EXTERN const OSUTF8CHAR* ASN1T_AdvisorySpeedType_ToString (OSINT32 value);

EXTERN int ASN1T_AdvisorySpeedType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_AdvisorySpeedType* pvalue);

EXTERN int ASN1T_AdvisorySpeedType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_AdvisorySpeedType* pvalue);

/**************************************************************/
/*                                                            */
/*  SpeedAdvice                                               */
/*                                                            */
/**************************************************************/
/*
SpeedAdvice ::= INTEGER (0..500)
     LSB units are 0.1 m/s^2
     the value 499 shall be used for values at or greater than 49.9 m/s
     the value 500 shall be used to indicate that speed is unavailable

*/
typedef OSUINT16 ASN1T_SpeedAdvice;

EXTERN int asn1PE_SpeedAdvice (OSCTXT* pctxt, ASN1T_SpeedAdvice value);

EXTERN int asn1PD_SpeedAdvice (OSCTXT* pctxt, ASN1T_SpeedAdvice* pvalue);

EXTERN int XmlEnc_SpeedAdvice (OSCTXT* pctxt, ASN1T_SpeedAdvice value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SpeedAdvice (OSCTXT* pctxt, ASN1T_SpeedAdvice* pvalue);

EXTERN int asn1JsonEnc_SpeedAdvice (OSCTXT *pctxt, ASN1T_SpeedAdvice *pvalue);

EXTERN int asn1JsonDec_SpeedAdvice (OSCTXT *pctxt, ASN1T_SpeedAdvice *pvalue);

EXTERN int asn1PrtToStrm_SpeedAdvice (OSCTXT *pctxt, 
   const char* name, const ASN1T_SpeedAdvice* pvalue);

EXTERN ASN1T_SpeedAdvice* new_ASN1T_SpeedAdvice (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  ZoneLength                                                */
/*                                                            */
/**************************************************************/
/*
ZoneLength ::= INTEGER (0..10000)
     Unit = 1 meter, 0 = unknown, 
     The value 10000 to be used for Distances >=10000 m
     (e.g., from known point to another point along a 
     known path, often against traffic flow direction 
     when used for measuring queues)

*/
typedef OSUINT16 ASN1T_ZoneLength;

EXTERN int asn1PE_ZoneLength (OSCTXT* pctxt, ASN1T_ZoneLength value);

EXTERN int asn1PD_ZoneLength (OSCTXT* pctxt, ASN1T_ZoneLength* pvalue);

EXTERN int XmlEnc_ZoneLength (OSCTXT* pctxt, ASN1T_ZoneLength value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ZoneLength (OSCTXT* pctxt, ASN1T_ZoneLength* pvalue);

EXTERN int asn1JsonEnc_ZoneLength (OSCTXT *pctxt, ASN1T_ZoneLength *pvalue);

EXTERN int asn1JsonDec_ZoneLength (OSCTXT *pctxt, ASN1T_ZoneLength *pvalue);

EXTERN int asn1PrtToStrm_ZoneLength (OSCTXT *pctxt, 
   const char* name, const ASN1T_ZoneLength* pvalue);

EXTERN ASN1T_ZoneLength* new_ASN1T_ZoneLength (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  AdvisorySpeed_regional_element                            */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'AdvisorySpeed'
*/
struct EXTERN ASN1T_AdvisorySpeed_regional_element {
   OSUINT8 regionId;
   ASN1TOpenType regExtValue;
} ;

EXTERN int asn1PE_AdvisorySpeed_regional_element (OSCTXT* pctxt, ASN1T_AdvisorySpeed_regional_element* pvalue);

EXTERN int asn1PD_AdvisorySpeed_regional_element (OSCTXT* pctxt, ASN1T_AdvisorySpeed_regional_element* pvalue);

EXTERN int XmlEnc_AdvisorySpeed_regional_element (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeed_regional_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AdvisorySpeed_regional_element (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeed_regional_element* pvalue);

EXTERN int asn1JsonEnc_AdvisorySpeed_regional_element (OSCTXT *pctxt, ASN1T_AdvisorySpeed_regional_element *pvalue);

EXTERN int asn1JsonDec_AdvisorySpeed_regional_element (OSCTXT *pctxt, ASN1T_AdvisorySpeed_regional_element *pvalue);

EXTERN int asn1PrtToStrm_AdvisorySpeed_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_AdvisorySpeed_regional_element* pvalue);

EXTERN ASN1T_AdvisorySpeed_regional_element* 
   new_ASN1T_AdvisorySpeed_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_AdvisorySpeed_regional_element (
   ASN1T_AdvisorySpeed_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_AdvisorySpeed_regional_element (OSCTXT *pctxt, 
   ASN1T_AdvisorySpeed_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  AdvisorySpeed_regional                                    */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'AdvisorySpeed'
*/
/* List of ASN1T_AdvisorySpeed_regional_element */
typedef ASN1TSeqOfList ASN1T_AdvisorySpeed_regional;

class EXTERN ASN1C_AdvisorySpeed_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_AdvisorySpeed_regional& msgData;
public:
   /**
    * Control class: ASN1C_AdvisorySpeed_regional
    * Data class:    ASN1T_AdvisorySpeed_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_AdvisorySpeed_regional (ASN1T_AdvisorySpeed_regional& data);

   /**
    * Control class: ASN1C_AdvisorySpeed_regional<br/>
    * Data class: ASN1T_AdvisorySpeed_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_AdvisorySpeed_regional (OSRTMessageBufferIF& msgBuf
      , ASN1T_AdvisorySpeed_regional& data);

   /**
    * Control class: ASN1C_AdvisorySpeed_regional<br/>
    * Data class: ASN1T_AdvisorySpeed_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_AdvisorySpeed_regional (ASN1CType& ccobj
      , ASN1T_AdvisorySpeed_regional& data);

   virtual ~ASN1C_AdvisorySpeed_regional () {}

   /**
    * Data class: ASN1T_AdvisorySpeed_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_AdvisorySpeed_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_AdvisorySpeed_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_AdvisorySpeed_regional_element* NewElement ();

   /**
    * Data class: ASN1T_AdvisorySpeed_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_AdvisorySpeed_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_AdvisorySpeed_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, ASN1T_AdvisorySpeed_regional* pmatches);

private:
   ASN1C_AdvisorySpeed_regional& operator= (const ASN1C_AdvisorySpeed_regional&) {return *this;}
} ;

EXTERN int asn1PE_AdvisorySpeed_regional (OSCTXT* pctxt, ASN1T_AdvisorySpeed_regional* pvalue);

EXTERN int asn1PD_AdvisorySpeed_regional (OSCTXT* pctxt, ASN1T_AdvisorySpeed_regional* pvalue);

EXTERN int XmlEnc_AdvisorySpeed_regional (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeed_regional* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AdvisorySpeed_regional (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeed_regional* pvalue);

EXTERN int asn1JsonEnc_AdvisorySpeed_regional (OSCTXT *pctxt, ASN1T_AdvisorySpeed_regional *pvalue);

EXTERN int asn1JsonDec_AdvisorySpeed_regional (OSCTXT *pctxt, ASN1T_AdvisorySpeed_regional *pvalue);

EXTERN int asn1PrtToStrm_AdvisorySpeed_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_AdvisorySpeed_regional* pvalue);

EXTERN int asn1Init_AdvisorySpeed_regional (ASN1T_AdvisorySpeed_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_AdvisorySpeed_regional (OSCTXT *pctxt, 
   ASN1T_AdvisorySpeed_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  AdvisorySpeed                                             */
/*                                                            */
/**************************************************************/
/*
AdvisorySpeed ::= SEQUENCE {
   type [0] AdvisorySpeedType,
               -- the type of advisory which this is.
   speed [1] SpeedAdvice OPTIONAL,
               -- See Section 11 for converting and translating speed 
               -- expressed in mph into units of m/s
               -- This element is optional ONLY when superceded 
               -- by the presence of a regional speed element found in
               -- Reg-AdvisorySpeed entry
   confidence [2] SpeedConfidence OPTIONAL,
               -- A confidence value for the above speed
   distance [3] ZoneLength OPTIONAL,
               -- Unit = 1 meter,  
               -- The distance indicates the region for which the advised speed 
               -- is recommended, it is specified upstream from the stop bar  
               -- along the connected egressing lane
   class [4] RestrictionClassID OPTIONAL,
               -- the vehicle types to which it applies
               -- when absent, the AdvisorySpeed applies to
               -- all motor vehicle types
   regional [5] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-AdvisorySpeed}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-AdvisorySpeed}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_AdvisorySpeed {
   struct {
      unsigned speedPresent : 1;
      unsigned confidencePresent : 1;
      unsigned distancePresent : 1;
      unsigned class_Present : 1;
      unsigned regionalPresent : 1;
   } m;
   ASN1T_AdvisorySpeedType type;
   ASN1T_SpeedAdvice speed;
   OSUINT32 confidence;
   ASN1T_ZoneLength distance;
   OSUINT8 class_;
   ASN1T_AdvisorySpeed_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_AdvisorySpeed ();
} ;

EXTERN int asn1PE_AdvisorySpeed (OSCTXT* pctxt, ASN1T_AdvisorySpeed* pvalue);

EXTERN int asn1PD_AdvisorySpeed (OSCTXT* pctxt, ASN1T_AdvisorySpeed* pvalue);

EXTERN int XmlEnc_AdvisorySpeed (OSCTXT* pctxt, ASN1T_AdvisorySpeed* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AdvisorySpeed (OSCTXT* pctxt, ASN1T_AdvisorySpeed* pvalue);

EXTERN int asn1JsonEnc_AdvisorySpeed (OSCTXT *pctxt, ASN1T_AdvisorySpeed *pvalue);

EXTERN int asn1JsonDec_AdvisorySpeed (OSCTXT *pctxt, ASN1T_AdvisorySpeed *pvalue);

EXTERN int asn1PrtToStrm_AdvisorySpeed (OSCTXT *pctxt, 
   const char* name, const ASN1T_AdvisorySpeed* pvalue);

EXTERN ASN1T_AdvisorySpeed* new_ASN1T_AdvisorySpeed (ASN1CType& ccobj);

EXTERN int asn1Init_AdvisorySpeed (ASN1T_AdvisorySpeed* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_AdvisorySpeed (OSCTXT *pctxt, ASN1T_AdvisorySpeed* pvalue);

/**************************************************************/
/*                                                            */
/*  AdvisorySpeedList                                         */
/*                                                            */
/**************************************************************/
/*
AdvisorySpeedList ::= SEQUENCE (SIZE (1..16)) OF AdvisorySpeed
*/
/* List of ASN1T_AdvisorySpeed */
typedef ASN1TSeqOfList ASN1T_AdvisorySpeedList;

class EXTERN ASN1C_AdvisorySpeedList :
public ASN1CSeqOfList
{
protected:
   ASN1T_AdvisorySpeedList& msgData;
public:
   /**
    * Control class: ASN1C_AdvisorySpeedList
    * Data class:    ASN1T_AdvisorySpeedList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_AdvisorySpeedList (ASN1T_AdvisorySpeedList& data);

   /**
    * Control class: ASN1C_AdvisorySpeedList<br/>
    * Data class: ASN1T_AdvisorySpeedList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_AdvisorySpeedList (OSRTMessageBufferIF& msgBuf
      , ASN1T_AdvisorySpeedList& data);

   /**
    * Control class: ASN1C_AdvisorySpeedList<br/>
    * Data class: ASN1T_AdvisorySpeedList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_AdvisorySpeedList (ASN1CType& ccobj, ASN1T_AdvisorySpeedList& data);

   virtual ~ASN1C_AdvisorySpeedList () {}

   /**
    * Data class: ASN1T_AdvisorySpeed<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_AdvisorySpeed* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_AdvisorySpeed.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_AdvisorySpeed* NewElement ();

   /**
    * Data class: ASN1T_AdvisorySpeed.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_AdvisorySpeed* AppendNewElement ();

private:
   ASN1C_AdvisorySpeedList& operator= (const ASN1C_AdvisorySpeedList&) {return *this;}
} ;

EXTERN int asn1PE_AdvisorySpeedList (OSCTXT* pctxt, ASN1T_AdvisorySpeedList* pvalue);

EXTERN int asn1PD_AdvisorySpeedList (OSCTXT* pctxt, ASN1T_AdvisorySpeedList* pvalue);

EXTERN int XmlEnc_AdvisorySpeedList (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeedList* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_AdvisorySpeedList (OSCTXT* pctxt, 
   ASN1T_AdvisorySpeedList* pvalue);

EXTERN int asn1JsonEnc_AdvisorySpeedList (OSCTXT *pctxt, ASN1T_AdvisorySpeedList *pvalue);

EXTERN int asn1JsonDec_AdvisorySpeedList (OSCTXT *pctxt, ASN1T_AdvisorySpeedList *pvalue);

EXTERN int asn1PrtToStrm_AdvisorySpeedList (OSCTXT *pctxt, 
   const char* name, const ASN1T_AdvisorySpeedList* pvalue);

EXTERN int asn1Init_AdvisorySpeedList (ASN1T_AdvisorySpeedList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_AdvisorySpeedList (OSCTXT *pctxt, 
   ASN1T_AdvisorySpeedList* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementEvent_regional_element                            */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'MovementEvent'
*/
struct EXTERN ASN1T_MovementEvent_regional_element {
   OSUINT8 regionId;
   struct  {
      /**
       * information object selector
       */
      OSUINT16 t;

      /**
       * Reg-MovementEvent information objects
       */
      union {
         /**
          * id: addGrpB
          */
         struct ASN1T_MovementEvent_addGrpB *_Reg_MovementEvent_addGrpB;

         ASN1TOpenType* extElem1;
      } u;
   } regExtValue;
   ASN1T_MovementEvent_regional_element ();
} ;

EXTERN int asn1PE_MovementEvent_regional_element (OSCTXT* pctxt, ASN1T_MovementEvent_regional_element* pvalue);

EXTERN int asn1PD_MovementEvent_regional_element (OSCTXT* pctxt, ASN1T_MovementEvent_regional_element* pvalue);

EXTERN int XmlEnc_MovementEvent_regional_element (OSCTXT* pctxt, 
   ASN1T_MovementEvent_regional_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementEvent_regional_element (OSCTXT* pctxt, 
   ASN1T_MovementEvent_regional_element* pvalue);

EXTERN int asn1JsonEnc_MovementEvent_regional_element (OSCTXT *pctxt, ASN1T_MovementEvent_regional_element *pvalue);

EXTERN int asn1JsonDec_MovementEvent_regional_element (OSCTXT *pctxt, ASN1T_MovementEvent_regional_element *pvalue);

EXTERN int asn1PrtToStrm_MovementEvent_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementEvent_regional_element* pvalue);

EXTERN ASN1T_MovementEvent_regional_element* 
   new_ASN1T_MovementEvent_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_MovementEvent_regional_element (
   ASN1T_MovementEvent_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementEvent_regional_element (OSCTXT *pctxt, 
   ASN1T_MovementEvent_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementEvent_regional                                    */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'MovementEvent'
*/
/* List of ASN1T_MovementEvent_regional_element */
typedef ASN1TSeqOfList ASN1T_MovementEvent_regional;

class EXTERN ASN1C_MovementEvent_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_MovementEvent_regional& msgData;
public:
   /**
    * Control class: ASN1C_MovementEvent_regional
    * Data class:    ASN1T_MovementEvent_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_MovementEvent_regional (ASN1T_MovementEvent_regional& data);

   /**
    * Control class: ASN1C_MovementEvent_regional<br/>
    * Data class: ASN1T_MovementEvent_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_MovementEvent_regional (OSRTMessageBufferIF& msgBuf
      , ASN1T_MovementEvent_regional& data);

   /**
    * Control class: ASN1C_MovementEvent_regional<br/>
    * Data class: ASN1T_MovementEvent_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_MovementEvent_regional (ASN1CType& ccobj
      , ASN1T_MovementEvent_regional& data);

   virtual ~ASN1C_MovementEvent_regional () {}

   /**
    * Data class: ASN1T_MovementEvent_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_MovementEvent_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_MovementEvent_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_MovementEvent_regional_element* NewElement ();

   /**
    * Data class: ASN1T_MovementEvent_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_MovementEvent_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_MovementEvent_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, ASN1T_MovementEvent_regional* pmatches);

private:
   ASN1C_MovementEvent_regional& operator= (const ASN1C_MovementEvent_regional&) {return *this;}
} ;

EXTERN int asn1PE_MovementEvent_regional (OSCTXT* pctxt, ASN1T_MovementEvent_regional* pvalue);

EXTERN int asn1PD_MovementEvent_regional (OSCTXT* pctxt, ASN1T_MovementEvent_regional* pvalue);

EXTERN int XmlEnc_MovementEvent_regional (OSCTXT* pctxt, 
   ASN1T_MovementEvent_regional* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementEvent_regional (OSCTXT* pctxt, 
   ASN1T_MovementEvent_regional* pvalue);

EXTERN int asn1JsonEnc_MovementEvent_regional (OSCTXT *pctxt, ASN1T_MovementEvent_regional *pvalue);

EXTERN int asn1JsonDec_MovementEvent_regional (OSCTXT *pctxt, ASN1T_MovementEvent_regional *pvalue);

EXTERN int asn1PrtToStrm_MovementEvent_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementEvent_regional* pvalue);

EXTERN int asn1Init_MovementEvent_regional (ASN1T_MovementEvent_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementEvent_regional (OSCTXT *pctxt, 
   ASN1T_MovementEvent_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementEvent                                             */
/*                                                            */
/**************************************************************/
/*
MovementEvent ::= SEQUENCE {
   eventState [0] MovementPhaseState,
                -- Consisting of:
                -- Phase state (the basic 11 states)
                -- Directional, protected, or permissive state
   timing [1] TimeChangeDetails OPTIONAL,
                -- Timing Data in UTC time stamps for event
                -- includes start and min/max end times of phase
                -- confidence and estimated next occurrence
   speeds [2] AdvisorySpeedList OPTIONAL,
                -- various speed advisories for use by
                -- general and specific types of vehicles
                -- supporting green-wave and other flow needs
                -- See Section 11 for converting and translating 
                -- speed expressed in mph into units of m/s
   regional [3] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-MovementEvent}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-MovementEvent}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_MovementEvent {
   struct {
      unsigned timingPresent : 1;
      unsigned speedsPresent : 1;
      unsigned regionalPresent : 1;
   } m;
   ASN1T_MovementPhaseState eventState;
   ASN1T_TimeChangeDetails timing;
   ASN1T_AdvisorySpeedList speeds;
   ASN1T_MovementEvent_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_MovementEvent ();
} ;

EXTERN int asn1PE_MovementEvent (OSCTXT* pctxt, ASN1T_MovementEvent* pvalue);

EXTERN int asn1PD_MovementEvent (OSCTXT* pctxt, ASN1T_MovementEvent* pvalue);

EXTERN int XmlEnc_MovementEvent (OSCTXT* pctxt, ASN1T_MovementEvent* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementEvent (OSCTXT* pctxt, ASN1T_MovementEvent* pvalue);

EXTERN int asn1JsonEnc_MovementEvent (OSCTXT *pctxt, ASN1T_MovementEvent *pvalue);

EXTERN int asn1JsonDec_MovementEvent (OSCTXT *pctxt, ASN1T_MovementEvent *pvalue);

EXTERN int asn1PrtToStrm_MovementEvent (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementEvent* pvalue);

EXTERN ASN1T_MovementEvent* new_ASN1T_MovementEvent (ASN1CType& ccobj);

EXTERN int asn1Init_MovementEvent (ASN1T_MovementEvent* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementEvent (OSCTXT *pctxt, ASN1T_MovementEvent* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementEventList                                         */
/*                                                            */
/**************************************************************/
/*
MovementEventList ::= SEQUENCE (SIZE (1..16)) OF MovementEvent
*/
/* List of ASN1T_MovementEvent */
typedef ASN1TSeqOfList ASN1T_MovementEventList;

class EXTERN ASN1C_MovementEventList :
public ASN1CSeqOfList
{
protected:
   ASN1T_MovementEventList& msgData;
public:
   /**
    * Control class: ASN1C_MovementEventList
    * Data class:    ASN1T_MovementEventList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_MovementEventList (ASN1T_MovementEventList& data);

   /**
    * Control class: ASN1C_MovementEventList<br/>
    * Data class: ASN1T_MovementEventList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_MovementEventList (OSRTMessageBufferIF& msgBuf
      , ASN1T_MovementEventList& data);

   /**
    * Control class: ASN1C_MovementEventList<br/>
    * Data class: ASN1T_MovementEventList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_MovementEventList (ASN1CType& ccobj, ASN1T_MovementEventList& data);

   virtual ~ASN1C_MovementEventList () {}

   /**
    * Data class: ASN1T_MovementEvent<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_MovementEvent* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_MovementEvent.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_MovementEvent* NewElement ();

   /**
    * Data class: ASN1T_MovementEvent.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_MovementEvent* AppendNewElement ();

private:
   ASN1C_MovementEventList& operator= (const ASN1C_MovementEventList&) {return *this;}
} ;

EXTERN int asn1PE_MovementEventList (OSCTXT* pctxt, ASN1T_MovementEventList* pvalue);

EXTERN int asn1PD_MovementEventList (OSCTXT* pctxt, ASN1T_MovementEventList* pvalue);

EXTERN int XmlEnc_MovementEventList (OSCTXT* pctxt, 
   ASN1T_MovementEventList* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementEventList (OSCTXT* pctxt, 
   ASN1T_MovementEventList* pvalue);

EXTERN int asn1JsonEnc_MovementEventList (OSCTXT *pctxt, ASN1T_MovementEventList *pvalue);

EXTERN int asn1JsonDec_MovementEventList (OSCTXT *pctxt, ASN1T_MovementEventList *pvalue);

EXTERN int asn1PrtToStrm_MovementEventList (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementEventList* pvalue);

EXTERN int asn1Init_MovementEventList (ASN1T_MovementEventList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementEventList (OSCTXT *pctxt, 
   ASN1T_MovementEventList* pvalue);

/**************************************************************/
/*                                                            */
/*  WaitOnStopline                                            */
/*                                                            */
/**************************************************************/
/*
WaitOnStopline ::= BOOLEAN
                            
          True or False
          If "true," the vehicles on this specific connecting 
          maneuver have to stop on the stop-line
          and not to enter the collision area

*/
typedef OSBOOL ASN1T_WaitOnStopline;

EXTERN int asn1PE_WaitOnStopline (OSCTXT* pctxt, ASN1T_WaitOnStopline value);

EXTERN int asn1PD_WaitOnStopline (OSCTXT* pctxt, ASN1T_WaitOnStopline* pvalue);

EXTERN int XmlEnc_WaitOnStopline (OSCTXT* pctxt, ASN1T_WaitOnStopline value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_WaitOnStopline (OSCTXT* pctxt, ASN1T_WaitOnStopline* pvalue)
   ;

EXTERN int asn1JsonEnc_WaitOnStopline (OSCTXT *pctxt, ASN1T_WaitOnStopline *pvalue);

EXTERN int asn1JsonDec_WaitOnStopline (OSCTXT *pctxt, ASN1T_WaitOnStopline *pvalue);

EXTERN int asn1PrtToStrm_WaitOnStopline (OSCTXT *pctxt, 
   const char* name, const ASN1T_WaitOnStopline* pvalue);

EXTERN ASN1T_WaitOnStopline* new_ASN1T_WaitOnStopline (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  PedestrianBicycleDetect                                   */
/*                                                            */
/**************************************************************/
/*
PedestrianBicycleDetect ::= BOOLEAN
                  true if ANY Pedestrians or Bicyclists are 
                  detected crossing the target lane or lanes

*/
typedef OSBOOL ASN1T_PedestrianBicycleDetect;

EXTERN int asn1PE_PedestrianBicycleDetect (OSCTXT* pctxt, ASN1T_PedestrianBicycleDetect value);

EXTERN int asn1PD_PedestrianBicycleDetect (OSCTXT* pctxt, ASN1T_PedestrianBicycleDetect* pvalue);

EXTERN int XmlEnc_PedestrianBicycleDetect (OSCTXT* pctxt, 
   ASN1T_PedestrianBicycleDetect value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_PedestrianBicycleDetect (OSCTXT* pctxt, 
   ASN1T_PedestrianBicycleDetect* pvalue);

EXTERN int asn1JsonEnc_PedestrianBicycleDetect (OSCTXT *pctxt, ASN1T_PedestrianBicycleDetect *pvalue);

EXTERN int asn1JsonDec_PedestrianBicycleDetect (OSCTXT *pctxt, ASN1T_PedestrianBicycleDetect *pvalue);

EXTERN int asn1PrtToStrm_PedestrianBicycleDetect (OSCTXT *pctxt, 
   const char* name, const ASN1T_PedestrianBicycleDetect* pvalue);

EXTERN ASN1T_PedestrianBicycleDetect* 
   new_ASN1T_PedestrianBicycleDetect (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  ConnectionManeuverAssist_regional_element                 */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'ConnectionManeuverAssist'
*/
struct EXTERN ASN1T_ConnectionManeuverAssist_regional_element {
   OSUINT8 regionId;
   struct  {
      /**
       * information object selector
       */
      OSUINT16 t;

      /**
       * Reg-ConnectionManeuverAssist information objects
       */
      union {
         /**
          * id: addGrpC
          */
         struct ASN1T_ConnectionManeuverAssist_addGrpC *_Reg_ConnectionManeuverAssist_addGrpC;

         ASN1TOpenType* extElem1;
      } u;
   } regExtValue;
   ASN1T_ConnectionManeuverAssist_regional_element ();
} ;

EXTERN int asn1PE_ConnectionManeuverAssist_regional_element (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist_regional_element* pvalue);

EXTERN int asn1PD_ConnectionManeuverAssist_regional_element (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist_regional_element* pvalue);

EXTERN int XmlEnc_ConnectionManeuverAssist_regional_element (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist_regional_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ConnectionManeuverAssist_regional_element (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist_regional_element* pvalue);

EXTERN int asn1JsonEnc_ConnectionManeuverAssist_regional_element (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist_regional_element *pvalue);

EXTERN int asn1JsonDec_ConnectionManeuverAssist_regional_element (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist_regional_element *pvalue);

EXTERN int asn1PrtToStrm_ConnectionManeuverAssist_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_ConnectionManeuverAssist_regional_element* pvalue);

EXTERN ASN1T_ConnectionManeuverAssist_regional_element* 
   new_ASN1T_ConnectionManeuverAssist_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_ConnectionManeuverAssist_regional_element (
   ASN1T_ConnectionManeuverAssist_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ConnectionManeuverAssist_regional_element (OSCTXT *pctxt, 
   ASN1T_ConnectionManeuverAssist_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  ConnectionManeuverAssist_regional                         */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'ConnectionManeuverAssist'
*/
/* List of ASN1T_ConnectionManeuverAssist_regional_element */
typedef ASN1TSeqOfList ASN1T_ConnectionManeuverAssist_regional;

class EXTERN ASN1C_ConnectionManeuverAssist_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_ConnectionManeuverAssist_regional& msgData;
public:
   /**
    * Control class: ASN1C_ConnectionManeuverAssist_regional
    * Data class:    ASN1T_ConnectionManeuverAssist_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_ConnectionManeuverAssist_regional
       (ASN1T_ConnectionManeuverAssist_regional& data);

   /**
    * Control class: ASN1C_ConnectionManeuverAssist_regional<br/>
    * Data class: ASN1T_ConnectionManeuverAssist_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_ConnectionManeuverAssist_regional (OSRTMessageBufferIF& msgBuf
      , ASN1T_ConnectionManeuverAssist_regional& data);

   /**
    * Control class: ASN1C_ConnectionManeuverAssist_regional<br/>
    * Data class: ASN1T_ConnectionManeuverAssist_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_ConnectionManeuverAssist_regional (ASN1CType& ccobj
      , ASN1T_ConnectionManeuverAssist_regional& data);

   virtual ~ASN1C_ConnectionManeuverAssist_regional () {}

   /**
    * Data class: ASN1T_ConnectionManeuverAssist_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_ConnectionManeuverAssist_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_ConnectionManeuverAssist_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_ConnectionManeuverAssist_regional_element* NewElement ();

   /**
    * Data class: ASN1T_ConnectionManeuverAssist_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_ConnectionManeuverAssist_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_ConnectionManeuverAssist_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, 
      ASN1T_ConnectionManeuverAssist_regional* pmatches);

private:
   ASN1C_ConnectionManeuverAssist_regional& operator= (const ASN1C_ConnectionManeuverAssist_regional&) {return *this;}
} ;

EXTERN int asn1PE_ConnectionManeuverAssist_regional (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist_regional* pvalue);

EXTERN int asn1PD_ConnectionManeuverAssist_regional (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist_regional* pvalue);

EXTERN int XmlEnc_ConnectionManeuverAssist_regional (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist_regional* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ConnectionManeuverAssist_regional (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist_regional* pvalue);

EXTERN int asn1JsonEnc_ConnectionManeuverAssist_regional (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist_regional *pvalue);

EXTERN int asn1JsonDec_ConnectionManeuverAssist_regional (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist_regional *pvalue);

EXTERN int asn1PrtToStrm_ConnectionManeuverAssist_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_ConnectionManeuverAssist_regional* pvalue);

EXTERN int asn1Init_ConnectionManeuverAssist_regional (
   ASN1T_ConnectionManeuverAssist_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ConnectionManeuverAssist_regional (OSCTXT *pctxt, 
   ASN1T_ConnectionManeuverAssist_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  ConnectionManeuverAssist                                  */
/*                                                            */
/**************************************************************/
/*
ConnectionManeuverAssist ::= SEQUENCE {
   connectionID [0] LaneConnectionID,
                        -- the common connectionID used by all lanes to which
                        -- this data applies 
                        -- (this value traces to ConnectsTo entries in lanes)
   -- Expected Clearance Information
   queueLength [1] ZoneLength OPTIONAL,
                        -- Unit = 1 meter, 0 = no queue
                        -- The distance from the stop line to the back 
                        -- edge of the last vehicle in the queue,                     
                        -- as measured along the lane center line.
   availableStorageLength [2] ZoneLength OPTIONAL,
                        -- Unit = 1 meter, 0 = no space remains
                        -- Distance (e.g., beginning from the downstream 
                        -- stop-line up to a given distance) with a high 
                        -- probability for successfully executing the 
                        -- connecting maneuver between the two lanes 
                        -- during the current cycle. 
                        -- Used for enhancing the awareness of vehicles 
                        -- to anticipate if they can pass the stop line
                        -- of the lane. Used for optimizing the green wave, 
                        -- due to knowledge of vehicles waiting in front 
                        -- of a red light (downstream).
                        -- The element nextTime in TimeChangeDetails
                        -- in the containing data frame contains the next 
                        -- timemark at which an active phase is expected, 
                        -- a form of storage flush interval.
   waitOnStop [3] WaitOnStopline OPTIONAL,
                        -- If "true," the vehicles on this specific connecting 
                        -- maneuver have to stop on the stop-line and not 
                        -- to enter the collision area 
   pedBicycleDetect [4] PedestrianBicycleDetect OPTIONAL,
                        -- true if ANY ped or bicycles are detected crossing 
                        -- the above lanes. Set to false ONLY if there is a 
                        -- high certainty that there are none present, 
                        -- otherwise element is not sent.
   regional [5] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-ConnectionManeuverAssist}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-ConnectionManeuverAssist}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_ConnectionManeuverAssist {
   struct {
      unsigned queueLengthPresent : 1;
      unsigned availableStorageLengthPresent : 1;
      unsigned waitOnStopPresent : 1;
      unsigned pedBicycleDetectPresent : 1;
      unsigned regionalPresent : 1;
   } m;
   OSUINT8 connectionID;
   ASN1T_ZoneLength queueLength;
   ASN1T_ZoneLength availableStorageLength;
   ASN1T_WaitOnStopline waitOnStop;
   ASN1T_PedestrianBicycleDetect pedBicycleDetect;
   ASN1T_ConnectionManeuverAssist_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_ConnectionManeuverAssist ();
} ;

EXTERN int asn1PE_ConnectionManeuverAssist (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist* pvalue);

EXTERN int asn1PD_ConnectionManeuverAssist (OSCTXT* pctxt, ASN1T_ConnectionManeuverAssist* pvalue);

EXTERN int XmlEnc_ConnectionManeuverAssist (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ConnectionManeuverAssist (OSCTXT* pctxt, 
   ASN1T_ConnectionManeuverAssist* pvalue);

EXTERN int asn1JsonEnc_ConnectionManeuverAssist (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist *pvalue);

EXTERN int asn1JsonDec_ConnectionManeuverAssist (OSCTXT *pctxt, ASN1T_ConnectionManeuverAssist *pvalue);

EXTERN int asn1PrtToStrm_ConnectionManeuverAssist (OSCTXT *pctxt, 
   const char* name, const ASN1T_ConnectionManeuverAssist* pvalue);

EXTERN ASN1T_ConnectionManeuverAssist* 
   new_ASN1T_ConnectionManeuverAssist (ASN1CType& ccobj);

EXTERN int asn1Init_ConnectionManeuverAssist (ASN1T_ConnectionManeuverAssist* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ConnectionManeuverAssist (OSCTXT *pctxt, 
   ASN1T_ConnectionManeuverAssist* pvalue);

/**************************************************************/
/*                                                            */
/*  ManeuverAssistList                                        */
/*                                                            */
/**************************************************************/
/*
ManeuverAssistList ::= SEQUENCE (SIZE (1..16)) OF ConnectionManeuverAssist
*/
/* List of ASN1T_ConnectionManeuverAssist */
typedef ASN1TSeqOfList ASN1T_ManeuverAssistList;

class EXTERN ASN1C_ManeuverAssistList :
public ASN1CSeqOfList
{
protected:
   ASN1T_ManeuverAssistList& msgData;
public:
   /**
    * Control class: ASN1C_ManeuverAssistList
    * Data class:    ASN1T_ManeuverAssistList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_ManeuverAssistList (ASN1T_ManeuverAssistList& data);

   /**
    * Control class: ASN1C_ManeuverAssistList<br/>
    * Data class: ASN1T_ManeuverAssistList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_ManeuverAssistList (OSRTMessageBufferIF& msgBuf
      , ASN1T_ManeuverAssistList& data);

   /**
    * Control class: ASN1C_ManeuverAssistList<br/>
    * Data class: ASN1T_ManeuverAssistList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_ManeuverAssistList (ASN1CType& ccobj, ASN1T_ManeuverAssistList& data);

   virtual ~ASN1C_ManeuverAssistList () {}

   /**
    * Data class: ASN1T_ConnectionManeuverAssist<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_ConnectionManeuverAssist* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_ConnectionManeuverAssist.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_ConnectionManeuverAssist* NewElement ();

   /**
    * Data class: ASN1T_ConnectionManeuverAssist.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_ConnectionManeuverAssist* AppendNewElement ();

private:
   ASN1C_ManeuverAssistList& operator= (const ASN1C_ManeuverAssistList&) {return *this;}
} ;

EXTERN int asn1PE_ManeuverAssistList (OSCTXT* pctxt, ASN1T_ManeuverAssistList* pvalue);

EXTERN int asn1PD_ManeuverAssistList (OSCTXT* pctxt, ASN1T_ManeuverAssistList* pvalue);

EXTERN int XmlEnc_ManeuverAssistList (OSCTXT* pctxt, 
   ASN1T_ManeuverAssistList* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_ManeuverAssistList (OSCTXT* pctxt, 
   ASN1T_ManeuverAssistList* pvalue);

EXTERN int asn1JsonEnc_ManeuverAssistList (OSCTXT *pctxt, ASN1T_ManeuverAssistList *pvalue);

EXTERN int asn1JsonDec_ManeuverAssistList (OSCTXT *pctxt, ASN1T_ManeuverAssistList *pvalue);

EXTERN int asn1PrtToStrm_ManeuverAssistList (OSCTXT *pctxt, 
   const char* name, const ASN1T_ManeuverAssistList* pvalue);

EXTERN int asn1Init_ManeuverAssistList (ASN1T_ManeuverAssistList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_ManeuverAssistList (OSCTXT *pctxt, 
   ASN1T_ManeuverAssistList* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementState_regional_element                            */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'MovementState'
*/
struct EXTERN ASN1T_MovementState_regional_element {
   OSUINT8 regionId;
   ASN1TOpenType regExtValue;
} ;

EXTERN int asn1PE_MovementState_regional_element (OSCTXT* pctxt, ASN1T_MovementState_regional_element* pvalue);

EXTERN int asn1PD_MovementState_regional_element (OSCTXT* pctxt, ASN1T_MovementState_regional_element* pvalue);

EXTERN int XmlEnc_MovementState_regional_element (OSCTXT* pctxt, 
   ASN1T_MovementState_regional_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementState_regional_element (OSCTXT* pctxt, 
   ASN1T_MovementState_regional_element* pvalue);

EXTERN int asn1JsonEnc_MovementState_regional_element (OSCTXT *pctxt, ASN1T_MovementState_regional_element *pvalue);

EXTERN int asn1JsonDec_MovementState_regional_element (OSCTXT *pctxt, ASN1T_MovementState_regional_element *pvalue);

EXTERN int asn1PrtToStrm_MovementState_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementState_regional_element* pvalue);

EXTERN ASN1T_MovementState_regional_element* 
   new_ASN1T_MovementState_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_MovementState_regional_element (
   ASN1T_MovementState_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementState_regional_element (OSCTXT *pctxt, 
   ASN1T_MovementState_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementState_regional                                    */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'MovementState'
*/
/* List of ASN1T_MovementState_regional_element */
typedef ASN1TSeqOfList ASN1T_MovementState_regional;

class EXTERN ASN1C_MovementState_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_MovementState_regional& msgData;
public:
   /**
    * Control class: ASN1C_MovementState_regional
    * Data class:    ASN1T_MovementState_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_MovementState_regional (ASN1T_MovementState_regional& data);

   /**
    * Control class: ASN1C_MovementState_regional<br/>
    * Data class: ASN1T_MovementState_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_MovementState_regional (OSRTMessageBufferIF& msgBuf
      , ASN1T_MovementState_regional& data);

   /**
    * Control class: ASN1C_MovementState_regional<br/>
    * Data class: ASN1T_MovementState_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_MovementState_regional (ASN1CType& ccobj
      , ASN1T_MovementState_regional& data);

   virtual ~ASN1C_MovementState_regional () {}

   /**
    * Data class: ASN1T_MovementState_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_MovementState_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_MovementState_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_MovementState_regional_element* NewElement ();

   /**
    * Data class: ASN1T_MovementState_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_MovementState_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_MovementState_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, ASN1T_MovementState_regional* pmatches);

private:
   ASN1C_MovementState_regional& operator= (const ASN1C_MovementState_regional&) {return *this;}
} ;

EXTERN int asn1PE_MovementState_regional (OSCTXT* pctxt, ASN1T_MovementState_regional* pvalue);

EXTERN int asn1PD_MovementState_regional (OSCTXT* pctxt, ASN1T_MovementState_regional* pvalue);

EXTERN int XmlEnc_MovementState_regional (OSCTXT* pctxt, 
   ASN1T_MovementState_regional* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementState_regional (OSCTXT* pctxt, 
   ASN1T_MovementState_regional* pvalue);

EXTERN int asn1JsonEnc_MovementState_regional (OSCTXT *pctxt, ASN1T_MovementState_regional *pvalue);

EXTERN int asn1JsonDec_MovementState_regional (OSCTXT *pctxt, ASN1T_MovementState_regional *pvalue);

EXTERN int asn1PrtToStrm_MovementState_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementState_regional* pvalue);

EXTERN int asn1Init_MovementState_regional (ASN1T_MovementState_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementState_regional (OSCTXT *pctxt, 
   ASN1T_MovementState_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementState                                             */
/*                                                            */
/**************************************************************/
/*
MovementState ::= SEQUENCE {
   movementName [0] DescriptiveName OPTIONAL,
                      -- uniquely defines movement by name   
                      -- human readable name for intersection  
                      -- to be used only in debug mode
   signalGroup [1] SignalGroupID,
                      -- the group id is used to map to lists 
                      -- of lanes (and their descriptions) 
                      -- which this MovementState data applies to 
                      -- see comments in the Remarks for usage details 
   state-time-speed [2] MovementEventList,
                      -- Consisting of sets of movement data with:
                      -- a)  SignalPhaseState
                      -- b)  TimeChangeDetails,  and 
                      -- c)  AdvisorySpeeds      (optional )
                      -- Note one or more of the movement events may be for 
                      -- a future time and that this allows conveying multiple 
                      -- predictive phase and movement timing for various uses
                      -- for the current signal group
   maneuverAssistList [3] ManeuverAssistList OPTIONAL,
                      -- This information may also be placed in the 
                      -- IntersectionState when common information applies to
                      -- different lanes in the same way
   regional [4] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-MovementState}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-MovementState}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_MovementState {
   struct {
      unsigned movementNamePresent : 1;
      unsigned maneuverAssistListPresent : 1;
      unsigned regionalPresent : 1;
   } m;
   const char* movementName;
   OSUINT8 signalGroup;
   ASN1T_MovementEventList state_time_speed;
   ASN1T_ManeuverAssistList maneuverAssistList;
   ASN1T_MovementState_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_MovementState ();
} ;

EXTERN int asn1PE_MovementState (OSCTXT* pctxt, ASN1T_MovementState* pvalue);

EXTERN int asn1PD_MovementState (OSCTXT* pctxt, ASN1T_MovementState* pvalue);

EXTERN int XmlEnc_MovementState (OSCTXT* pctxt, ASN1T_MovementState* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementState (OSCTXT* pctxt, ASN1T_MovementState* pvalue);

EXTERN int asn1JsonEnc_MovementState (OSCTXT *pctxt, ASN1T_MovementState *pvalue);

EXTERN int asn1JsonDec_MovementState (OSCTXT *pctxt, ASN1T_MovementState *pvalue);

EXTERN int asn1PrtToStrm_MovementState (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementState* pvalue);

EXTERN ASN1T_MovementState* new_ASN1T_MovementState (ASN1CType& ccobj);

EXTERN int asn1Init_MovementState (ASN1T_MovementState* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementState (OSCTXT *pctxt, ASN1T_MovementState* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementList                                              */
/*                                                            */
/**************************************************************/
/*
MovementList ::= SEQUENCE (SIZE (1..255)) OF MovementState
*/
/* List of ASN1T_MovementState */
typedef ASN1TSeqOfList ASN1T_MovementList;

class EXTERN ASN1C_MovementList :
public ASN1CSeqOfList
{
protected:
   ASN1T_MovementList& msgData;
public:
   /**
    * Control class: ASN1C_MovementList
    * Data class:    ASN1T_MovementList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_MovementList (ASN1T_MovementList& data);

   /**
    * Control class: ASN1C_MovementList<br/>
    * Data class: ASN1T_MovementList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_MovementList (OSRTMessageBufferIF& msgBuf, ASN1T_MovementList& data);

   /**
    * Control class: ASN1C_MovementList<br/>
    * Data class: ASN1T_MovementList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_MovementList (ASN1CType& ccobj, ASN1T_MovementList& data);

   virtual ~ASN1C_MovementList () {}

   /**
    * Data class: ASN1T_MovementState<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_MovementState* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_MovementState.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_MovementState* NewElement ();

   /**
    * Data class: ASN1T_MovementState.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_MovementState* AppendNewElement ();

private:
   ASN1C_MovementList& operator= (const ASN1C_MovementList&) {return *this;}
} ;

EXTERN int asn1PE_MovementList (OSCTXT* pctxt, ASN1T_MovementList* pvalue);

EXTERN int asn1PD_MovementList (OSCTXT* pctxt, ASN1T_MovementList* pvalue);

EXTERN int XmlEnc_MovementList (OSCTXT* pctxt, ASN1T_MovementList* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementList (OSCTXT* pctxt, ASN1T_MovementList* pvalue);

EXTERN int asn1JsonEnc_MovementList (OSCTXT *pctxt, ASN1T_MovementList *pvalue);

EXTERN int asn1JsonDec_MovementList (OSCTXT *pctxt, ASN1T_MovementList *pvalue);

EXTERN int asn1PrtToStrm_MovementList (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementList* pvalue);

EXTERN int asn1Init_MovementList (ASN1T_MovementList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementList (OSCTXT *pctxt, ASN1T_MovementList* pvalue);

/**************************************************************/
/*                                                            */
/*  IntersectionState_regional_element                        */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'IntersectionState'
*/
struct EXTERN ASN1T_IntersectionState_regional_element {
   OSUINT8 regionId;
   struct  {
      /**
       * information object selector
       */
      OSUINT16 t;

      /**
       * Reg-IntersectionState information objects
       */
      union {
         /**
          * id: addGrpC
          */
         struct ASN1T_IntersectionState_addGrpC *_Reg_IntersectionState_addGrpC;

         ASN1TOpenType* extElem1;
      } u;
   } regExtValue;
   ASN1T_IntersectionState_regional_element ();
} ;

EXTERN int asn1PE_IntersectionState_regional_element (OSCTXT* pctxt, ASN1T_IntersectionState_regional_element* pvalue);

EXTERN int asn1PD_IntersectionState_regional_element (OSCTXT* pctxt, ASN1T_IntersectionState_regional_element* pvalue);

EXTERN int XmlEnc_IntersectionState_regional_element (OSCTXT* pctxt, 
   ASN1T_IntersectionState_regional_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_IntersectionState_regional_element (OSCTXT* pctxt, 
   ASN1T_IntersectionState_regional_element* pvalue);

EXTERN int asn1JsonEnc_IntersectionState_regional_element (OSCTXT *pctxt, ASN1T_IntersectionState_regional_element *pvalue);

EXTERN int asn1JsonDec_IntersectionState_regional_element (OSCTXT *pctxt, ASN1T_IntersectionState_regional_element *pvalue);

EXTERN int asn1PrtToStrm_IntersectionState_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_IntersectionState_regional_element* pvalue);

EXTERN ASN1T_IntersectionState_regional_element* 
   new_ASN1T_IntersectionState_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_IntersectionState_regional_element (
   ASN1T_IntersectionState_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_IntersectionState_regional_element (OSCTXT *pctxt, 
   ASN1T_IntersectionState_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  IntersectionState_regional                                */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'IntersectionState'
*/
/* List of ASN1T_IntersectionState_regional_element */
typedef ASN1TSeqOfList ASN1T_IntersectionState_regional;

class EXTERN ASN1C_IntersectionState_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_IntersectionState_regional& msgData;
public:
   /**
    * Control class: ASN1C_IntersectionState_regional
    * Data class:    ASN1T_IntersectionState_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_IntersectionState_regional (ASN1T_IntersectionState_regional& data);

   /**
    * Control class: ASN1C_IntersectionState_regional<br/>
    * Data class: ASN1T_IntersectionState_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_IntersectionState_regional (OSRTMessageBufferIF& msgBuf
      , ASN1T_IntersectionState_regional& data);

   /**
    * Control class: ASN1C_IntersectionState_regional<br/>
    * Data class: ASN1T_IntersectionState_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_IntersectionState_regional (ASN1CType& ccobj
      , ASN1T_IntersectionState_regional& data);

   virtual ~ASN1C_IntersectionState_regional () {}

   /**
    * Data class: ASN1T_IntersectionState_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_IntersectionState_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_IntersectionState_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_IntersectionState_regional_element* NewElement ();

   /**
    * Data class: ASN1T_IntersectionState_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_IntersectionState_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_IntersectionState_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, 
      ASN1T_IntersectionState_regional* pmatches);

private:
   ASN1C_IntersectionState_regional& operator= (const ASN1C_IntersectionState_regional&) {return *this;}
} ;

EXTERN int asn1PE_IntersectionState_regional (OSCTXT* pctxt, ASN1T_IntersectionState_regional* pvalue);

EXTERN int asn1PD_IntersectionState_regional (OSCTXT* pctxt, ASN1T_IntersectionState_regional* pvalue);

EXTERN int XmlEnc_IntersectionState_regional (OSCTXT* pctxt, 
   ASN1T_IntersectionState_regional* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_IntersectionState_regional (OSCTXT* pctxt, 
   ASN1T_IntersectionState_regional* pvalue);

EXTERN int asn1JsonEnc_IntersectionState_regional (OSCTXT *pctxt, ASN1T_IntersectionState_regional *pvalue);

EXTERN int asn1JsonDec_IntersectionState_regional (OSCTXT *pctxt, ASN1T_IntersectionState_regional *pvalue);

EXTERN int asn1PrtToStrm_IntersectionState_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_IntersectionState_regional* pvalue);

EXTERN int asn1Init_IntersectionState_regional (
   ASN1T_IntersectionState_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_IntersectionState_regional (OSCTXT *pctxt, 
   ASN1T_IntersectionState_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  IntersectionState                                         */
/*                                                            */
/**************************************************************/
/*
IntersectionState ::= SEQUENCE {
   name [0] DescriptiveName OPTIONAL,
                -- human readable name for intersection  
                -- to be used only in debug mode
   id [1] IntersectionReferenceID,
                -- A globally unique value set, consisting of a 
                -- regionID and intersection ID assignment
                -- provides a unique mapping to the 
                -- intersection MAP in question
                -- which provides complete location 
                -- and approach/move/lane data
   revision [2] MsgCount,
   status [3] IntersectionStatusObject,
                -- general status of the controller(s)
   moy [4] MinuteOfTheYear OPTIONAL,
                -- Minute of current UTC year
                -- used only with messages to be archived 
   timeStamp [5] DSecond OPTIONAL,
                -- the mSec point in the current UTC minute that
                -- this message was constructed
   enabledLanes [6] EnabledLaneList OPTIONAL,
                -- a list of lanes where the RevocableLane bit 
                -- has been set which are now active and 
                -- therefore part of the current intersection
   states [7] MovementList,
                -- Each Movement is given in turn
                -- and contains its signal phase state, 
                -- mapping to the lanes it applies to, and
                -- point in time it will end, and it
                -- may contain both active and future states 
   maneuverAssistList [8] ManeuverAssistList OPTIONAL,
                -- Assist data
   regional [9] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-IntersectionState}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-IntersectionState}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_IntersectionState {
   struct {
      unsigned namePresent : 1;
      unsigned moyPresent : 1;
      unsigned timeStampPresent : 1;
      unsigned enabledLanesPresent : 1;
      unsigned maneuverAssistListPresent : 1;
      unsigned regionalPresent : 1;
   } m;
   const char* name;
   struct ASN1T_IntersectionReferenceID *id;
   OSUINT8 revision;
   ASN1T_IntersectionStatusObject status;
   OSUINT32 moy;
   OSUINT16 timeStamp;
   ASN1T_EnabledLaneList enabledLanes;
   ASN1T_MovementList states;
   ASN1T_ManeuverAssistList maneuverAssistList;
   ASN1T_IntersectionState_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_IntersectionState ();
} ;

EXTERN int asn1PE_IntersectionState (OSCTXT* pctxt, ASN1T_IntersectionState* pvalue);

EXTERN int asn1PD_IntersectionState (OSCTXT* pctxt, ASN1T_IntersectionState* pvalue);

EXTERN int XmlEnc_IntersectionState (OSCTXT* pctxt, 
   ASN1T_IntersectionState* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_IntersectionState (OSCTXT* pctxt, 
   ASN1T_IntersectionState* pvalue);

EXTERN int asn1JsonEnc_IntersectionState (OSCTXT *pctxt, ASN1T_IntersectionState *pvalue);

EXTERN int asn1JsonDec_IntersectionState (OSCTXT *pctxt, ASN1T_IntersectionState *pvalue);

EXTERN int asn1PrtToStrm_IntersectionState (OSCTXT *pctxt, 
   const char* name, const ASN1T_IntersectionState* pvalue);

EXTERN ASN1T_IntersectionState* new_ASN1T_IntersectionState (ASN1CType& ccobj)
   ;

EXTERN int asn1Init_IntersectionState (ASN1T_IntersectionState* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_IntersectionState (OSCTXT *pctxt, 
   ASN1T_IntersectionState* pvalue);

/**************************************************************/
/*                                                            */
/*  IntersectionStateList                                     */
/*                                                            */
/**************************************************************/
/*
IntersectionStateList ::= SEQUENCE (SIZE (1..32)) OF IntersectionState
*/
/* List of ASN1T_IntersectionState */
typedef ASN1TSeqOfList ASN1T_IntersectionStateList;

class EXTERN ASN1C_IntersectionStateList :
public ASN1CSeqOfList
{
protected:
   ASN1T_IntersectionStateList& msgData;
public:
   /**
    * Control class: ASN1C_IntersectionStateList
    * Data class:    ASN1T_IntersectionStateList
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_IntersectionStateList (ASN1T_IntersectionStateList& data);

   /**
    * Control class: ASN1C_IntersectionStateList<br/>
    * Data class: ASN1T_IntersectionStateList<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_IntersectionStateList (OSRTMessageBufferIF& msgBuf
      , ASN1T_IntersectionStateList& data);

   /**
    * Control class: ASN1C_IntersectionStateList<br/>
    * Data class: ASN1T_IntersectionStateList<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_IntersectionStateList (ASN1CType& ccobj
      , ASN1T_IntersectionStateList& data);

   virtual ~ASN1C_IntersectionStateList () {}

   /**
    * Data class: ASN1T_IntersectionState<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_IntersectionState* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_IntersectionState.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_IntersectionState* NewElement ();

   /**
    * Data class: ASN1T_IntersectionState.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_IntersectionState* AppendNewElement ();

private:
   ASN1C_IntersectionStateList& operator= (const ASN1C_IntersectionStateList&) {return *this;}
} ;

EXTERN int asn1PE_IntersectionStateList (OSCTXT* pctxt, ASN1T_IntersectionStateList* pvalue);

EXTERN int asn1PD_IntersectionStateList (OSCTXT* pctxt, ASN1T_IntersectionStateList* pvalue);

EXTERN int XmlEnc_IntersectionStateList (OSCTXT* pctxt, 
   ASN1T_IntersectionStateList* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_IntersectionStateList (OSCTXT* pctxt, 
   ASN1T_IntersectionStateList* pvalue);

EXTERN int asn1JsonEnc_IntersectionStateList (OSCTXT *pctxt, ASN1T_IntersectionStateList *pvalue);

EXTERN int asn1JsonDec_IntersectionStateList (OSCTXT *pctxt, ASN1T_IntersectionStateList *pvalue);

EXTERN int asn1PrtToStrm_IntersectionStateList (OSCTXT *pctxt, 
   const char* name, const ASN1T_IntersectionStateList* pvalue);

EXTERN int asn1Init_IntersectionStateList (ASN1T_IntersectionStateList* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_IntersectionStateList (OSCTXT *pctxt, 
   ASN1T_IntersectionStateList* pvalue);

/**************************************************************/
/*                                                            */
/*  SPAT_regional_element                                     */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'SPAT'
*/
struct EXTERN ASN1T_SPAT_regional_element {
   OSUINT8 regionId;
   ASN1TOpenType regExtValue;
} ;

EXTERN int asn1PE_SPAT_regional_element (OSCTXT* pctxt, ASN1T_SPAT_regional_element* pvalue);

EXTERN int asn1PD_SPAT_regional_element (OSCTXT* pctxt, ASN1T_SPAT_regional_element* pvalue);

EXTERN int XmlEnc_SPAT_regional_element (OSCTXT* pctxt, 
   ASN1T_SPAT_regional_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SPAT_regional_element (OSCTXT* pctxt, 
   ASN1T_SPAT_regional_element* pvalue);

EXTERN int asn1JsonEnc_SPAT_regional_element (OSCTXT *pctxt, ASN1T_SPAT_regional_element *pvalue);

EXTERN int asn1JsonDec_SPAT_regional_element (OSCTXT *pctxt, ASN1T_SPAT_regional_element *pvalue);

EXTERN int asn1PrtToStrm_SPAT_regional_element (OSCTXT *pctxt, 
   const char* name, const ASN1T_SPAT_regional_element* pvalue);

EXTERN ASN1T_SPAT_regional_element* 
   new_ASN1T_SPAT_regional_element (ASN1CType& ccobj);

EXTERN int asn1Init_SPAT_regional_element (ASN1T_SPAT_regional_element* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_SPAT_regional_element (OSCTXT *pctxt, 
   ASN1T_SPAT_regional_element* pvalue);

/**************************************************************/
/*                                                            */
/*  SPAT_regional                                             */
/*                                                            */
/**************************************************************/
/*
Type was extracted from 'SPAT'
*/
/* List of ASN1T_SPAT_regional_element */
typedef ASN1TSeqOfList ASN1T_SPAT_regional;

class EXTERN ASN1C_SPAT_regional :
public ASN1CSeqOfList
{
protected:
   ASN1T_SPAT_regional& msgData;
public:
   /**
    * Control class: ASN1C_SPAT_regional
    * Data class:    ASN1T_SPAT_regional
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_SPAT_regional (ASN1T_SPAT_regional& data);

   /**
    * Control class: ASN1C_SPAT_regional<br/>
    * Data class: ASN1T_SPAT_regional<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_SPAT_regional (OSRTMessageBufferIF& msgBuf, ASN1T_SPAT_regional& data);

   /**
    * Control class: ASN1C_SPAT_regional<br/>
    * Data class: ASN1T_SPAT_regional<br/>
    *
    * Constructs an instance of the control class given an instance of
    * an \c ASN1CType control class and an instance of the
    * given data class.
    *
    * @param ccobj  Reference to a control class instance.
    * @param data   Reference to an instance of the data class. */
   ASN1C_SPAT_regional (ASN1CType& ccobj, ASN1T_SPAT_regional& data);

   virtual ~ASN1C_SPAT_regional () {}

   /**
    * Data class: ASN1T_SPAT_regional_element<br/>
    *
    * Appends an instance of the data class to the end of the list.
    *
    * @param  elem     Pointer to an instance of the data class.
    */
   void Append (ASN1T_SPAT_regional_element* elem);

   void freeMemory();
   /**
    * Data class: ASN1T_SPAT_regional_element.<br/>
    *
    * Creates a new instance of the data class.
    *
    * @return    Pointer to the new instance of the data class.
    */
   ASN1T_SPAT_regional_element* NewElement ();

   /**
    * Data class: ASN1T_SPAT_regional_element.<br/>
    *
    * Creates a new instance of the data class and appends it
    * to the end of the list.
    *
    * @return    Pointer to a new instance of the data class.
    */
   ASN1T_SPAT_regional_element* AppendNewElement ();

   /* Get IE using regionId key value */
   /* index element type is forward referenced */
   ASN1T_SPAT_regional_element* GetIE (OSUINT8 regionId);

   /* Get all matching IEs using regionId key value */
   int GetAllIEs (OSUINT8 regionId, ASN1T_SPAT_regional* pmatches);

private:
   ASN1C_SPAT_regional& operator= (const ASN1C_SPAT_regional&) {return *this;}
} ;

EXTERN int asn1PE_SPAT_regional (OSCTXT* pctxt, ASN1T_SPAT_regional* pvalue);

EXTERN int asn1PD_SPAT_regional (OSCTXT* pctxt, ASN1T_SPAT_regional* pvalue);

EXTERN int XmlEnc_SPAT_regional (OSCTXT* pctxt, ASN1T_SPAT_regional* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SPAT_regional (OSCTXT* pctxt, ASN1T_SPAT_regional* pvalue);

EXTERN int asn1JsonEnc_SPAT_regional (OSCTXT *pctxt, ASN1T_SPAT_regional *pvalue);

EXTERN int asn1JsonDec_SPAT_regional (OSCTXT *pctxt, ASN1T_SPAT_regional *pvalue);

EXTERN int asn1PrtToStrm_SPAT_regional (OSCTXT *pctxt, 
   const char* name, const ASN1T_SPAT_regional* pvalue);

EXTERN int asn1Init_SPAT_regional (ASN1T_SPAT_regional* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_SPAT_regional (OSCTXT *pctxt, ASN1T_SPAT_regional* pvalue);

/**************************************************************/
/*                                                            */
/*  SPAT                                                      */
/*                                                            */
/**************************************************************/
/*
SPAT ::= SEQUENCE {
   timeStamp [0] MinuteOfTheYear OPTIONAL,
   name [1] DescriptiveName OPTIONAL,
                 -- human readable name for this collection 
                 -- to be used only in debug mode
   intersections [2] IntersectionStateList,
                 -- sets of SPAT data (one per intersection)  
   -- If PrioritizationResponse data is required, it is found 
   -- in the RegionalSPAT entry below
   regional [3] SEQUENCE (SIZE (1..4)) OF SEQUENCE {
      regionId [0] REG-EXT-ID-AND-TYPE.&id ({Reg-SPAT}),
      regExtValue [1] EXPLICIT REG-EXT-ID-AND-TYPE.&Type ({Reg-SPAT}{@regionId})
   } OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_SPAT {
   struct {
      unsigned timeStampPresent : 1;
      unsigned namePresent : 1;
      unsigned regionalPresent : 1;
   } m;
   OSUINT32 timeStamp;
   const char* name;
   ASN1T_IntersectionStateList intersections;
   ASN1T_SPAT_regional regional;
   ASN1TSeqExt extElem1;
   ASN1T_SPAT ();
} ;

EXTERN int asn1PE_SPAT (OSCTXT* pctxt, ASN1T_SPAT* pvalue);

EXTERN int asn1PD_SPAT (OSCTXT* pctxt, ASN1T_SPAT* pvalue);

EXTERN int XmlEnc_SPAT (OSCTXT* pctxt, ASN1T_SPAT* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SPAT (OSCTXT* pctxt, ASN1T_SPAT* pvalue);

EXTERN int asn1JsonEnc_SPAT (OSCTXT *pctxt, ASN1T_SPAT *pvalue);

EXTERN int asn1JsonDec_SPAT (OSCTXT *pctxt, ASN1T_SPAT *pvalue);

EXTERN int asn1PrtToStrm_SPAT (OSCTXT *pctxt, 
   const char* name, const ASN1T_SPAT* pvalue);

EXTERN ASN1T_SPAT* new_ASN1T_SPAT (ASN1CType& ccobj);

EXTERN int asn1Init_SPAT (ASN1T_SPAT* pvalue, OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_SPAT (OSCTXT *pctxt, ASN1T_SPAT* pvalue);

#endif
