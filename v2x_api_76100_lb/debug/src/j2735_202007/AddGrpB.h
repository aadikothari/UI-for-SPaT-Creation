/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).
 */
#ifndef ADDGRPB_H
#define ADDGRPB_H

#include <stdio.h>
#include <stdlib.h>
#include "rtpersrc/asn1PerCppTypes.h"
#include "rtsrc/asn1CppTypes.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtsrc/asn1type.h"
#include "rtxmlsrc/asn1xml.h"
#include "rtxmlsrc/rtXmlCppMsgBuf.h"
#include "rtsrc/asn1type.h"
#include "rtjsonsrc/asn1json.h"
#include "rtjsonsrc/rtJsonCppMsgBuf.h"

/**
 * Header file for ASN.1 module AddGrpB
 */
/**************************************************************/
/*                                                            */
/*  Angle                                                     */
/*                                                            */
/**************************************************************/
/*
Angle ::= INTEGER (0..239)
    Unsigned units of 1.5 degree, in 1 octet
    the true north is 0, positive is clockwise
    the values 240 to 254 shall not be sent
    the value 255 (0xFF) indicates an invalid value

*/
typedef OSUINT8 ASN1T_Angle;

class EXTERN ASN1C_Angle :
public ASN1CType
{
protected:
   ASN1T_Angle& msgData;
public:
   /**
    * Control class: ASN1C_Angle
    * Data class:    ASN1T_Angle
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_Angle (ASN1T_Angle& data);

   /**
    * Control class: ASN1C_Angle<br/>
    * Data class: ASN1T_Angle<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_Angle (OSRTMessageBufferIF& msgBuf, ASN1T_Angle& data);

   virtual ~ASN1C_Angle () {}

   /**
    * Data class: ASN1T_Angle<br/>
    *
    * Gets a mutable instance of the data class.
    *
    * @return Reference to a mutable instance of data class ASN1T_Angle.
    */
   inline ASN1T_Angle& getData () { return msgData; }

   /**
    * Data class: ASN1T_Angle<br/>
    * Gets a non-mutable instance of the data class.
    *
    * @return Reference to a non-mutable instance of data class ASN1T_Angle.
    */
   inline const ASN1T_Angle& getData () const { return msgData; }

   // standard encode/decode methods (defined in ASN1CType base class):
   // int Encode ();
   // int Decode ();

   // stream encode/decode methods:
   /**
    * Encodes into a specified encode buffer.
    *
    * @param msgBuf Reference to an encode buffer.
    * @return A status value (0 indicates success).
    */
   int EncodeTo (OSRTMessageBufferIF& msgBuf);

   /**
    * Decodes from a specified decode buffer.
    *
    * @param msgBuf Reference to a decode buffer.
    * @return A status value (0 indicates success).
    */
   int DecodeFrom (OSRTMessageBufferIF& msgBuf, OSBOOL free = FALSE);

   /**
    * Writes the contents of the object to a user-defined stream using
    * a user-defined print callback function.  See the documentation for
    * the setPrintStream() method.
    *
    * @param name A name for the object's contents.  If not specified,
    *             Angle will be used for the name.
    * @return Always returns 0.
    */
   int toStream (const char* name = "Angle");
   /**
    * Declares a print stream handler function.
    *
    * @param strmCallback Pointer to a function defined according to the
    *                     rtxPrintCallback signature.
    * @return A status value (0 indicates success).
    */
   int setPrintStream (rtxPrintCallback strmCallback, void* pStrmInfo);
private:
   ASN1C_Angle& operator= (const ASN1C_Angle&) {return *this;}
} ;

EXTERN int asn1PE_Angle (OSCTXT* pctxt, ASN1T_Angle value);

EXTERN int asn1PD_Angle (OSCTXT* pctxt, ASN1T_Angle* pvalue);

EXTERN int XmlEnc_Angle (OSCTXT* pctxt, ASN1T_Angle value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Angle (OSCTXT* pctxt, ASN1T_Angle* pvalue);

EXTERN int asn1JsonEnc_Angle (OSCTXT *pctxt, ASN1T_Angle *pvalue);

EXTERN int asn1JsonDec_Angle (OSCTXT *pctxt, ASN1T_Angle *pvalue);

EXTERN int asn1PrtToStrm_Angle (OSCTXT *pctxt, 
   const char* name, const ASN1T_Angle* pvalue);

EXTERN ASN1T_Angle* new_ASN1T_Angle (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Day                                                       */
/*                                                            */
/**************************************************************/
/*
Day ::= INTEGER (0..255)
    BCD coding of Day of Month, in 1 octet
    values with nibble values between 1010 and 1111 shall not be sent
    except that the value xxx (0xFF shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_Day;

EXTERN int asn1PE_Day (OSCTXT* pctxt, ASN1T_Day value);

EXTERN int asn1PD_Day (OSCTXT* pctxt, ASN1T_Day* pvalue);

EXTERN int XmlEnc_Day (OSCTXT* pctxt, ASN1T_Day value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Day (OSCTXT* pctxt, ASN1T_Day* pvalue);

EXTERN int asn1JsonEnc_Day (OSCTXT *pctxt, ASN1T_Day *pvalue);

EXTERN int asn1JsonDec_Day (OSCTXT *pctxt, ASN1T_Day *pvalue);

EXTERN int asn1PrtToStrm_Day (OSCTXT *pctxt, 
   const char* name, const ASN1T_Day* pvalue);

EXTERN ASN1T_Day* new_ASN1T_Day (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  DayOfWeek                                                 */
/*                                                            */
/**************************************************************/
/*
DayOfWeek ::= ENUMERATED { unknown(0), monday(1), tuesday(2), wednesday(3), thursday(4), friday(5), saturday(6), sunday(7) }
    Encoding as per above, in 3 bits
    the value 0x00 shall indicate an invalid value

*/
struct EXTERN DayOfWeek {
   enum Root {
      unknown = 0,
      monday = 1,
      tuesday = 2,
      wednesday = 3,
      thursday = 4,
      friday = 5,
      saturday = 6,
      sunday = 7
   } ;
} ;

typedef OSUINT32 ASN1T_DayOfWeek;

EXTERN int asn1PE_DayOfWeek (OSCTXT* pctxt, ASN1T_DayOfWeek value);

EXTERN int asn1PD_DayOfWeek (OSCTXT* pctxt, ASN1T_DayOfWeek* pvalue);

EXTERN int XmlEnc_DayOfWeek (OSCTXT* pctxt, ASN1T_DayOfWeek value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_DayOfWeek (OSCTXT* pctxt, ASN1T_DayOfWeek* pvalue);

EXTERN int asn1JsonEnc_DayOfWeek (OSCTXT *pctxt, ASN1T_DayOfWeek *pvalue);

EXTERN int asn1JsonDec_DayOfWeek (OSCTXT *pctxt, ASN1T_DayOfWeek *pvalue);

EXTERN int asn1PrtToStrm_DayOfWeek (OSCTXT *pctxt, 
   const char* name, const ASN1T_DayOfWeek* pvalue);

EXTERN ASN1T_DayOfWeek* new_ASN1T_DayOfWeek (ASN1CType& ccobj);

EXTERN extern const OSEnumItem ASN1T_DayOfWeek_ENUMTAB[];
#define ASN1T_DayOfWeek_ENUMTABSIZE 8

EXTERN const OSUTF8CHAR* ASN1T_DayOfWeek_ToString (OSINT32 value);

EXTERN int ASN1T_DayOfWeek_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_DayOfWeek* pvalue);

EXTERN int ASN1T_DayOfWeek_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_DayOfWeek* pvalue);

/**************************************************************/
/*                                                            */
/*  DegreesLat                                                */
/*                                                            */
/**************************************************************/
/*
DegreesLat ::= INTEGER (-90..90)
    Signed units of degrees, in 1 octets
    the values  +91 to +126 shall not be sent
    the values -128 to  -91 shall not be sent
    the value 127 (0x7F) shall indicate an invalid value

*/
typedef OSINT8 ASN1T_DegreesLat;

EXTERN int asn1PE_DegreesLat (OSCTXT* pctxt, ASN1T_DegreesLat value);

EXTERN int asn1PD_DegreesLat (OSCTXT* pctxt, ASN1T_DegreesLat* pvalue);

EXTERN int XmlEnc_DegreesLat (OSCTXT* pctxt, ASN1T_DegreesLat value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_DegreesLat (OSCTXT* pctxt, ASN1T_DegreesLat* pvalue);

EXTERN int asn1JsonEnc_DegreesLat (OSCTXT *pctxt, ASN1T_DegreesLat *pvalue);

EXTERN int asn1JsonDec_DegreesLat (OSCTXT *pctxt, ASN1T_DegreesLat *pvalue);

EXTERN int asn1PrtToStrm_DegreesLat (OSCTXT *pctxt, 
   const char* name, const ASN1T_DegreesLat* pvalue);

EXTERN ASN1T_DegreesLat* new_ASN1T_DegreesLat (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  DegreesLong                                               */
/*                                                            */
/**************************************************************/
/*
DegreesLong ::= INTEGER (-180..180)
    Signed units of degrees, in 2 octets
    the values +181 to +32766 shall not be sent
    the values -181 to -32768 shall not be sent
    the value 32767 (0x7FFF shall indicate an invalid value

*/
typedef OSINT16 ASN1T_DegreesLong;

EXTERN int asn1PE_DegreesLong (OSCTXT* pctxt, ASN1T_DegreesLong value);

EXTERN int asn1PD_DegreesLong (OSCTXT* pctxt, ASN1T_DegreesLong* pvalue);

EXTERN int XmlEnc_DegreesLong (OSCTXT* pctxt, ASN1T_DegreesLong value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_DegreesLong (OSCTXT* pctxt, ASN1T_DegreesLong* pvalue);

EXTERN int asn1JsonEnc_DegreesLong (OSCTXT *pctxt, ASN1T_DegreesLong *pvalue);

EXTERN int asn1JsonDec_DegreesLong (OSCTXT *pctxt, ASN1T_DegreesLong *pvalue);

EXTERN int asn1PrtToStrm_DegreesLong (OSCTXT *pctxt, 
   const char* name, const ASN1T_DegreesLong* pvalue);

EXTERN ASN1T_DegreesLong* new_ASN1T_DegreesLong (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Elevation                                                 */
/*                                                            */
/**************************************************************/
/*
Elevation ::= INTEGER (-32768..32767)
   Signed units of 0.1m (10cm), in 2 octets
   the value 32767 (0x7FFF) shall indicate an invalid value

*/
typedef OSINT16 ASN1T_Elevation;

EXTERN int asn1PE_Elevation (OSCTXT* pctxt, ASN1T_Elevation value);

EXTERN int asn1PD_Elevation (OSCTXT* pctxt, ASN1T_Elevation* pvalue);

EXTERN int XmlEnc_Elevation (OSCTXT* pctxt, ASN1T_Elevation value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Elevation (OSCTXT* pctxt, ASN1T_Elevation* pvalue);

EXTERN int asn1JsonEnc_Elevation (OSCTXT *pctxt, ASN1T_Elevation *pvalue);

EXTERN int asn1JsonDec_Elevation (OSCTXT *pctxt, ASN1T_Elevation *pvalue);

EXTERN int asn1PrtToStrm_Elevation (OSCTXT *pctxt, 
   const char* name, const ASN1T_Elevation* pvalue);

EXTERN ASN1T_Elevation* new_ASN1T_Elevation (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Holiday                                                   */
/*                                                            */
/**************************************************************/
/*
Holiday ::= ENUMERATED { weekday(0), holiday(1) }
    Encoding as per above, in 1 bit

*/
struct EXTERN Holiday {
   enum Root {
      weekday = 0,
      holiday = 1
   } ;
} ;

typedef OSUINT32 ASN1T_Holiday;

EXTERN int asn1PE_Holiday (OSCTXT* pctxt, ASN1T_Holiday value);

EXTERN int asn1PD_Holiday (OSCTXT* pctxt, ASN1T_Holiday* pvalue);

EXTERN int XmlEnc_Holiday (OSCTXT* pctxt, ASN1T_Holiday value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Holiday (OSCTXT* pctxt, ASN1T_Holiday* pvalue);

EXTERN int asn1JsonEnc_Holiday (OSCTXT *pctxt, ASN1T_Holiday *pvalue);

EXTERN int asn1JsonDec_Holiday (OSCTXT *pctxt, ASN1T_Holiday *pvalue);

EXTERN int asn1PrtToStrm_Holiday (OSCTXT *pctxt, 
   const char* name, const ASN1T_Holiday* pvalue);

EXTERN ASN1T_Holiday* new_ASN1T_Holiday (ASN1CType& ccobj);

EXTERN extern const OSEnumItem ASN1T_Holiday_ENUMTAB[];
#define ASN1T_Holiday_ENUMTABSIZE 2

EXTERN const OSUTF8CHAR* ASN1T_Holiday_ToString (OSINT32 value);

EXTERN int ASN1T_Holiday_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_Holiday* pvalue);

EXTERN int ASN1T_Holiday_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_Holiday* pvalue);

/**************************************************************/
/*                                                            */
/*  Hour                                                      */
/*                                                            */
/**************************************************************/
/*
Hour ::= INTEGER (0..255)
    BCD coding of Hour of a Day, in 1 octet
    values above upper nibble 0010 and lower nibble 0100 shall not be sent
    values with lower nibble values between 1010 and 1111 shall not be sent
    except that the value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_Hour;

EXTERN int asn1PE_Hour (OSCTXT* pctxt, ASN1T_Hour value);

EXTERN int asn1PD_Hour (OSCTXT* pctxt, ASN1T_Hour* pvalue);

EXTERN int XmlEnc_Hour (OSCTXT* pctxt, ASN1T_Hour value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Hour (OSCTXT* pctxt, ASN1T_Hour* pvalue);

EXTERN int asn1JsonEnc_Hour (OSCTXT *pctxt, ASN1T_Hour *pvalue);

EXTERN int asn1JsonDec_Hour (OSCTXT *pctxt, ASN1T_Hour *pvalue);

EXTERN int asn1PrtToStrm_Hour (OSCTXT *pctxt, 
   const char* name, const ASN1T_Hour* pvalue);

EXTERN ASN1T_Hour* new_ASN1T_Hour (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  LatitudeDMS                                               */
/*                                                            */
/**************************************************************/
/*
LatitudeDMS ::= INTEGER (-32400000..32400000)
    Signed units of 0.01 seconds of a minute of a degree of Latitude
    Providing a range of plus-minus 90 degrees
    in a 4 octet value when implicit or in BER forms
    the value 0x7FFF FFFF shall indicate an invalid value

*/
typedef OSINT32 ASN1T_LatitudeDMS;

EXTERN int asn1PE_LatitudeDMS (OSCTXT* pctxt, ASN1T_LatitudeDMS value);

EXTERN int asn1PD_LatitudeDMS (OSCTXT* pctxt, ASN1T_LatitudeDMS* pvalue);

EXTERN int XmlEnc_LatitudeDMS (OSCTXT* pctxt, ASN1T_LatitudeDMS value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LatitudeDMS (OSCTXT* pctxt, ASN1T_LatitudeDMS* pvalue);

EXTERN int asn1JsonEnc_LatitudeDMS (OSCTXT *pctxt, ASN1T_LatitudeDMS *pvalue);

EXTERN int asn1JsonDec_LatitudeDMS (OSCTXT *pctxt, ASN1T_LatitudeDMS *pvalue);

EXTERN int asn1PrtToStrm_LatitudeDMS (OSCTXT *pctxt, 
   const char* name, const ASN1T_LatitudeDMS* pvalue);

EXTERN ASN1T_LatitudeDMS* new_ASN1T_LatitudeDMS (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  LongitudeDMS                                              */
/*                                                            */
/**************************************************************/
/*
LongitudeDMS ::= INTEGER (-64800000..64800000)
    Signed units of 0.01 seconds of a minute of a degree of Longitude
    Providing a range of plus-minus 180 degrees
    in a 4 octet value when implicit or in BER forms
    the value 0x7FFF FFFF shall indicate an invalid value

*/
typedef OSINT32 ASN1T_LongitudeDMS;

EXTERN int asn1PE_LongitudeDMS (OSCTXT* pctxt, ASN1T_LongitudeDMS value);

EXTERN int asn1PD_LongitudeDMS (OSCTXT* pctxt, ASN1T_LongitudeDMS* pvalue);

EXTERN int XmlEnc_LongitudeDMS (OSCTXT* pctxt, ASN1T_LongitudeDMS value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LongitudeDMS (OSCTXT* pctxt, ASN1T_LongitudeDMS* pvalue);

EXTERN int asn1JsonEnc_LongitudeDMS (OSCTXT *pctxt, ASN1T_LongitudeDMS *pvalue);

EXTERN int asn1JsonDec_LongitudeDMS (OSCTXT *pctxt, ASN1T_LongitudeDMS *pvalue);

EXTERN int asn1PrtToStrm_LongitudeDMS (OSCTXT *pctxt, 
   const char* name, const ASN1T_LongitudeDMS* pvalue);

EXTERN ASN1T_LongitudeDMS* new_ASN1T_LongitudeDMS (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  MaxTimetoChange                                           */
/*                                                            */
/**************************************************************/
/*
MaxTimetoChange ::= INTEGER (0..2402)
    Unsigned units of 0.1 seconds, in 2 octets
    the value 2401 shall indicate 'forever'
    the values 2402 to 65534 shall not be sent
    the value 65535 (0xFFFF) shall indicate an invalid value

*/
typedef OSUINT16 ASN1T_MaxTimetoChange;

EXTERN int asn1PE_MaxTimetoChange (OSCTXT* pctxt, ASN1T_MaxTimetoChange value);

EXTERN int asn1PD_MaxTimetoChange (OSCTXT* pctxt, ASN1T_MaxTimetoChange* pvalue);

EXTERN int XmlEnc_MaxTimetoChange (OSCTXT* pctxt, ASN1T_MaxTimetoChange value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MaxTimetoChange (OSCTXT* pctxt, ASN1T_MaxTimetoChange* pvalue
   );

EXTERN int asn1JsonEnc_MaxTimetoChange (OSCTXT *pctxt, ASN1T_MaxTimetoChange *pvalue);

EXTERN int asn1JsonDec_MaxTimetoChange (OSCTXT *pctxt, ASN1T_MaxTimetoChange *pvalue);

EXTERN int asn1PrtToStrm_MaxTimetoChange (OSCTXT *pctxt, 
   const char* name, const ASN1T_MaxTimetoChange* pvalue);

EXTERN ASN1T_MaxTimetoChange* new_ASN1T_MaxTimetoChange (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  MinTimetoChange                                           */
/*                                                            */
/**************************************************************/
/*
MinTimetoChange ::= INTEGER (0..2402)
    Unsigned units of 0.1 seconds, in 2 octets
    the value 2401 shall indicate 'forever'
    the values 2402 to 32766 shall not be sent
    the value 32767(0x7FFF) shall indicate an invalid value
    Note that:
    The MSB is used as a flag and set to one to
    indicate that the value does not count down.
    Under this condition the movement phase may end
    immediately if certain condition are meet.

*/
typedef OSUINT16 ASN1T_MinTimetoChange;

EXTERN int asn1PE_MinTimetoChange (OSCTXT* pctxt, ASN1T_MinTimetoChange value);

EXTERN int asn1PD_MinTimetoChange (OSCTXT* pctxt, ASN1T_MinTimetoChange* pvalue);

EXTERN int XmlEnc_MinTimetoChange (OSCTXT* pctxt, ASN1T_MinTimetoChange value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MinTimetoChange (OSCTXT* pctxt, ASN1T_MinTimetoChange* pvalue
   );

EXTERN int asn1JsonEnc_MinTimetoChange (OSCTXT *pctxt, ASN1T_MinTimetoChange *pvalue);

EXTERN int asn1JsonDec_MinTimetoChange (OSCTXT *pctxt, ASN1T_MinTimetoChange *pvalue);

EXTERN int asn1PrtToStrm_MinTimetoChange (OSCTXT *pctxt, 
   const char* name, const ASN1T_MinTimetoChange* pvalue);

EXTERN ASN1T_MinTimetoChange* new_ASN1T_MinTimetoChange (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Minute                                                    */
/*                                                            */
/**************************************************************/
/*
Minute ::= INTEGER (0..255)
    BCD coding of Minute of an Hour, in 1 octet 
    values above a combined BCD value of 59 (>59)
    (i.e., 0110 0000) shall not be sent
    except that value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_Minute;

EXTERN int asn1PE_Minute (OSCTXT* pctxt, ASN1T_Minute value);

EXTERN int asn1PD_Minute (OSCTXT* pctxt, ASN1T_Minute* pvalue);

EXTERN int XmlEnc_Minute (OSCTXT* pctxt, ASN1T_Minute value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Minute (OSCTXT* pctxt, ASN1T_Minute* pvalue);

EXTERN int asn1JsonEnc_Minute (OSCTXT *pctxt, ASN1T_Minute *pvalue);

EXTERN int asn1JsonDec_Minute (OSCTXT *pctxt, ASN1T_Minute *pvalue);

EXTERN int asn1PrtToStrm_Minute (OSCTXT *pctxt, 
   const char* name, const ASN1T_Minute* pvalue);

EXTERN ASN1T_Minute* new_ASN1T_Minute (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  MinutesAngle                                              */
/*                                                            */
/**************************************************************/
/*
MinutesAngle ::= INTEGER (0..59)
    Unsigned units of minutes of an angle, in 1 octet 
    values above 59 shall not be sent
    except that value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_MinutesAngle;

EXTERN int asn1PE_MinutesAngle (OSCTXT* pctxt, ASN1T_MinutesAngle value);

EXTERN int asn1PD_MinutesAngle (OSCTXT* pctxt, ASN1T_MinutesAngle* pvalue);

EXTERN int XmlEnc_MinutesAngle (OSCTXT* pctxt, ASN1T_MinutesAngle value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MinutesAngle (OSCTXT* pctxt, ASN1T_MinutesAngle* pvalue);

EXTERN int asn1JsonEnc_MinutesAngle (OSCTXT *pctxt, ASN1T_MinutesAngle *pvalue);

EXTERN int asn1JsonDec_MinutesAngle (OSCTXT *pctxt, ASN1T_MinutesAngle *pvalue);

EXTERN int asn1PrtToStrm_MinutesAngle (OSCTXT *pctxt, 
   const char* name, const ASN1T_MinutesAngle* pvalue);

EXTERN ASN1T_MinutesAngle* new_ASN1T_MinutesAngle (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Month                                                     */
/*                                                            */
/**************************************************************/
/*
Month ::= INTEGER (1..255)
    BCD coding of Month of a year, in 1 octet
    values above a combined BCD value of 12 (>12)
    (i.e., 0001 0011) shall not be sent
    except that value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_Month;

EXTERN int asn1PE_Month (OSCTXT* pctxt, ASN1T_Month value);

EXTERN int asn1PD_Month (OSCTXT* pctxt, ASN1T_Month* pvalue);

EXTERN int XmlEnc_Month (OSCTXT* pctxt, ASN1T_Month value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Month (OSCTXT* pctxt, ASN1T_Month* pvalue);

EXTERN int asn1JsonEnc_Month (OSCTXT *pctxt, ASN1T_Month *pvalue);

EXTERN int asn1JsonDec_Month (OSCTXT *pctxt, ASN1T_Month *pvalue);

EXTERN int asn1PrtToStrm_Month (OSCTXT *pctxt, 
   const char* name, const ASN1T_Month* pvalue);

EXTERN ASN1T_Month* new_ASN1T_Month (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  MsgCount                                                  */
/*                                                            */
/**************************************************************/
/*
MsgCount ::= INTEGER (0..255)
    a count value which is incremented with each use
    the next value after 255 shall be one
    value 0 (0x00) shall indicate that MsgCount is not available

*/
typedef OSUINT8 ASN1T_MsgCount;

class EXTERN ASN1C_MsgCount :
public ASN1CType
{
protected:
   ASN1T_MsgCount& msgData;
public:
   /**
    * Control class: ASN1C_MsgCount
    * Data class:    ASN1T_MsgCount
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_MsgCount (ASN1T_MsgCount& data);

   /**
    * Control class: ASN1C_MsgCount<br/>
    * Data class: ASN1T_MsgCount<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_MsgCount (OSRTMessageBufferIF& msgBuf, ASN1T_MsgCount& data);

   virtual ~ASN1C_MsgCount () {}

   /**
    * Data class: ASN1T_MsgCount<br/>
    *
    * Gets a mutable instance of the data class.
    *
    * @return Reference to a mutable instance of data class ASN1T_MsgCount.
    */
   inline ASN1T_MsgCount& getData () { return msgData; }

   /**
    * Data class: ASN1T_MsgCount<br/>
    * Gets a non-mutable instance of the data class.
    *
    * @return Reference to a non-mutable instance of data class ASN1T_MsgCount.
    */
   inline const ASN1T_MsgCount& getData () const { return msgData; }

   // standard encode/decode methods (defined in ASN1CType base class):
   // int Encode ();
   // int Decode ();

   // stream encode/decode methods:
   /**
    * Encodes into a specified encode buffer.
    *
    * @param msgBuf Reference to an encode buffer.
    * @return A status value (0 indicates success).
    */
   int EncodeTo (OSRTMessageBufferIF& msgBuf);

   /**
    * Decodes from a specified decode buffer.
    *
    * @param msgBuf Reference to a decode buffer.
    * @return A status value (0 indicates success).
    */
   int DecodeFrom (OSRTMessageBufferIF& msgBuf, OSBOOL free = FALSE);

   /**
    * Writes the contents of the object to a user-defined stream using
    * a user-defined print callback function.  See the documentation for
    * the setPrintStream() method.
    *
    * @param name A name for the object's contents.  If not specified,
    *             MsgCount will be used for the name.
    * @return Always returns 0.
    */
   int toStream (const char* name = "MsgCount");
   /**
    * Declares a print stream handler function.
    *
    * @param strmCallback Pointer to a function defined according to the
    *                     rtxPrintCallback signature.
    * @return A status value (0 indicates success).
    */
   int setPrintStream (rtxPrintCallback strmCallback, void* pStrmInfo);
private:
   ASN1C_MsgCount& operator= (const ASN1C_MsgCount&) {return *this;}
} ;

EXTERN int asn1PE_MsgCount (OSCTXT* pctxt, ASN1T_MsgCount value);

EXTERN int asn1PD_MsgCount (OSCTXT* pctxt, ASN1T_MsgCount* pvalue);

EXTERN int XmlEnc_MsgCount (OSCTXT* pctxt, ASN1T_MsgCount value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MsgCount (OSCTXT* pctxt, ASN1T_MsgCount* pvalue);

EXTERN int asn1JsonEnc_MsgCount (OSCTXT *pctxt, ASN1T_MsgCount *pvalue);

EXTERN int asn1JsonDec_MsgCount (OSCTXT *pctxt, ASN1T_MsgCount *pvalue);

EXTERN int asn1PrtToStrm_MsgCount (OSCTXT *pctxt, 
   const char* name, const ASN1T_MsgCount* pvalue);

EXTERN ASN1T_MsgCount* new_ASN1T_MsgCount (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Second                                                    */
/*                                                            */
/**************************************************************/
/*
Second ::= INTEGER (0..60)
    BCD coding of a second of time, in 1 octet 
    values above a combined BCD value of 60
    (i.e., 0110 0000) shall not be sent
    except that value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_Second;

EXTERN int asn1PE_Second (OSCTXT* pctxt, ASN1T_Second value);

EXTERN int asn1PD_Second (OSCTXT* pctxt, ASN1T_Second* pvalue);

EXTERN int XmlEnc_Second (OSCTXT* pctxt, ASN1T_Second value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Second (OSCTXT* pctxt, ASN1T_Second* pvalue);

EXTERN int asn1JsonEnc_Second (OSCTXT *pctxt, ASN1T_Second *pvalue);

EXTERN int asn1JsonDec_Second (OSCTXT *pctxt, ASN1T_Second *pvalue);

EXTERN int asn1PrtToStrm_Second (OSCTXT *pctxt, 
   const char* name, const ASN1T_Second* pvalue);

EXTERN ASN1T_Second* new_ASN1T_Second (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  SecondsAngle                                              */
/*                                                            */
/**************************************************************/
/*
SecondsAngle ::= INTEGER (0..5999)
    Unsigned units of 1/100th seconds of angle, in 2 octets
    values from 6000 to 65534 shall not be sent
    the value 65535 (0xFFFF) shall indicate an invalid value

*/
typedef OSUINT16 ASN1T_SecondsAngle;

EXTERN int asn1PE_SecondsAngle (OSCTXT* pctxt, ASN1T_SecondsAngle value);

EXTERN int asn1PD_SecondsAngle (OSCTXT* pctxt, ASN1T_SecondsAngle* pvalue);

EXTERN int XmlEnc_SecondsAngle (OSCTXT* pctxt, ASN1T_SecondsAngle value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SecondsAngle (OSCTXT* pctxt, ASN1T_SecondsAngle* pvalue);

EXTERN int asn1JsonEnc_SecondsAngle (OSCTXT *pctxt, ASN1T_SecondsAngle *pvalue);

EXTERN int asn1JsonDec_SecondsAngle (OSCTXT *pctxt, ASN1T_SecondsAngle *pvalue);

EXTERN int asn1PrtToStrm_SecondsAngle (OSCTXT *pctxt, 
   const char* name, const ASN1T_SecondsAngle* pvalue);

EXTERN ASN1T_SecondsAngle* new_ASN1T_SecondsAngle (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  SummerTime                                                */
/*                                                            */
/**************************************************************/
/*
SummerTime ::= ENUMERATED { notInSummerTime(0), inSummerTime(1) }
    Encoding as per above, in 1 bit

*/
struct EXTERN SummerTime {
   enum Root {
      notInSummerTime = 0,
      inSummerTime = 1
   } ;
} ;

typedef OSUINT32 ASN1T_SummerTime;

EXTERN int asn1PE_SummerTime (OSCTXT* pctxt, ASN1T_SummerTime value);

EXTERN int asn1PD_SummerTime (OSCTXT* pctxt, ASN1T_SummerTime* pvalue);

EXTERN int XmlEnc_SummerTime (OSCTXT* pctxt, ASN1T_SummerTime value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_SummerTime (OSCTXT* pctxt, ASN1T_SummerTime* pvalue);

EXTERN int asn1JsonEnc_SummerTime (OSCTXT *pctxt, ASN1T_SummerTime *pvalue);

EXTERN int asn1JsonDec_SummerTime (OSCTXT *pctxt, ASN1T_SummerTime *pvalue);

EXTERN int asn1PrtToStrm_SummerTime (OSCTXT *pctxt, 
   const char* name, const ASN1T_SummerTime* pvalue);

EXTERN ASN1T_SummerTime* new_ASN1T_SummerTime (ASN1CType& ccobj);

EXTERN extern const OSEnumItem ASN1T_SummerTime_ENUMTAB[];
#define ASN1T_SummerTime_ENUMTABSIZE 2

EXTERN const OSUTF8CHAR* ASN1T_SummerTime_ToString (OSINT32 value);

EXTERN int ASN1T_SummerTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_SummerTime* pvalue);

EXTERN int ASN1T_SummerTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_SummerTime* pvalue);

/**************************************************************/
/*                                                            */
/*  TenthSecond                                               */
/*                                                            */
/**************************************************************/
/*
TenthSecond ::= INTEGER (0..9)
    Unsigned units of 100 milliseconds, in 1 octet
    values from 10 to 254 shall not be sent
    the value 255 (0xFF) shall indicate an invalid value

*/
typedef OSUINT8 ASN1T_TenthSecond;

EXTERN int asn1PE_TenthSecond (OSCTXT* pctxt, ASN1T_TenthSecond value);

EXTERN int asn1PD_TenthSecond (OSCTXT* pctxt, ASN1T_TenthSecond* pvalue);

EXTERN int XmlEnc_TenthSecond (OSCTXT* pctxt, ASN1T_TenthSecond value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_TenthSecond (OSCTXT* pctxt, ASN1T_TenthSecond* pvalue);

EXTERN int asn1JsonEnc_TenthSecond (OSCTXT *pctxt, ASN1T_TenthSecond *pvalue);

EXTERN int asn1JsonDec_TenthSecond (OSCTXT *pctxt, ASN1T_TenthSecond *pvalue);

EXTERN int asn1PrtToStrm_TenthSecond (OSCTXT *pctxt, 
   const char* name, const ASN1T_TenthSecond* pvalue);

EXTERN ASN1T_TenthSecond* new_ASN1T_TenthSecond (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  TimeRemaining                                             */
/*                                                            */
/**************************************************************/
/*
TimeRemaining ::= INTEGER (0..9001)
     Unsigned units of 0.1 seconds, spanning 15 minutes, in 2 octets
     the value 9001 shall indicate 'forever'
     values from 9002 to 65534 shall not be sent
     the value 65535 (0xFFFF) shall indicate an invalid value

*/
typedef OSUINT16 ASN1T_TimeRemaining;

EXTERN int asn1PE_TimeRemaining (OSCTXT* pctxt, ASN1T_TimeRemaining value);

EXTERN int asn1PD_TimeRemaining (OSCTXT* pctxt, ASN1T_TimeRemaining* pvalue);

EXTERN int XmlEnc_TimeRemaining (OSCTXT* pctxt, ASN1T_TimeRemaining value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_TimeRemaining (OSCTXT* pctxt, ASN1T_TimeRemaining* pvalue);

EXTERN int asn1JsonEnc_TimeRemaining (OSCTXT *pctxt, ASN1T_TimeRemaining *pvalue);

EXTERN int asn1JsonDec_TimeRemaining (OSCTXT *pctxt, ASN1T_TimeRemaining *pvalue);

EXTERN int asn1PrtToStrm_TimeRemaining (OSCTXT *pctxt, 
   const char* name, const ASN1T_TimeRemaining* pvalue);

EXTERN ASN1T_TimeRemaining* new_ASN1T_TimeRemaining (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Year                                                      */
/*                                                            */
/**************************************************************/
/*
Year ::= INTEGER (1..65535)
    BCD coding of four digits of the year A.D. in 2 octets 
    values with nibble values between 1010 and 1111 shall not be sent
    except that the value 65535 (0xFFFF) shall indicate an invalid value

*/
typedef OSUINT16 ASN1T_Year;

EXTERN int asn1PE_Year (OSCTXT* pctxt, ASN1T_Year value);

EXTERN int asn1PD_Year (OSCTXT* pctxt, ASN1T_Year* pvalue);

EXTERN int XmlEnc_Year (OSCTXT* pctxt, ASN1T_Year value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Year (OSCTXT* pctxt, ASN1T_Year* pvalue);

EXTERN int asn1JsonEnc_Year (OSCTXT *pctxt, ASN1T_Year *pvalue);

EXTERN int asn1JsonDec_Year (OSCTXT *pctxt, ASN1T_Year *pvalue);

EXTERN int asn1PrtToStrm_Year (OSCTXT *pctxt, 
   const char* name, const ASN1T_Year* pvalue);

EXTERN ASN1T_Year* new_ASN1T_Year (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  LatitudeDMS2                                              */
/*                                                            */
/**************************************************************/
/*
LatitudeDMS2 ::= SEQUENCE {
   d [0] DegreesLat, -- units of degrees
   m [1] MinutesAngle, -- units of minutes
   s [2] SecondsAngle -- units of 1/100th seconds
}
      total size of 4 octets (32 bits) when implicit encoding is used

*/
struct EXTERN ASN1T_LatitudeDMS2 {
   ASN1T_DegreesLat d;
   ASN1T_MinutesAngle m_;
   ASN1T_SecondsAngle s;
} ;

EXTERN int asn1PE_LatitudeDMS2 (OSCTXT* pctxt, ASN1T_LatitudeDMS2* pvalue);

EXTERN int asn1PD_LatitudeDMS2 (OSCTXT* pctxt, ASN1T_LatitudeDMS2* pvalue);

EXTERN int XmlEnc_LatitudeDMS2 (OSCTXT* pctxt, ASN1T_LatitudeDMS2* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LatitudeDMS2 (OSCTXT* pctxt, ASN1T_LatitudeDMS2* pvalue);

EXTERN int asn1JsonEnc_LatitudeDMS2 (OSCTXT *pctxt, ASN1T_LatitudeDMS2 *pvalue);

EXTERN int asn1JsonDec_LatitudeDMS2 (OSCTXT *pctxt, ASN1T_LatitudeDMS2 *pvalue);

EXTERN int asn1PrtToStrm_LatitudeDMS2 (OSCTXT *pctxt, 
   const char* name, const ASN1T_LatitudeDMS2* pvalue);

EXTERN ASN1T_LatitudeDMS2* new_ASN1T_LatitudeDMS2 (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  LongitudeDMS2                                             */
/*                                                            */
/**************************************************************/
/*
LongitudeDMS2 ::= SEQUENCE {
   d [0] DegreesLong, -- units of degrees
   m [1] MinutesAngle, -- units of minutes
   s [2] SecondsAngle -- units of 1/100th seconds
}
      total size of 5 octets (40 bits) when implicit encoding is used

*/
struct EXTERN ASN1T_LongitudeDMS2 {
   ASN1T_DegreesLong d;
   ASN1T_MinutesAngle m_;
   ASN1T_SecondsAngle s;
} ;

EXTERN int asn1PE_LongitudeDMS2 (OSCTXT* pctxt, ASN1T_LongitudeDMS2* pvalue);

EXTERN int asn1PD_LongitudeDMS2 (OSCTXT* pctxt, ASN1T_LongitudeDMS2* pvalue);

EXTERN int XmlEnc_LongitudeDMS2 (OSCTXT* pctxt, ASN1T_LongitudeDMS2* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LongitudeDMS2 (OSCTXT* pctxt, ASN1T_LongitudeDMS2* pvalue);

EXTERN int asn1JsonEnc_LongitudeDMS2 (OSCTXT *pctxt, ASN1T_LongitudeDMS2 *pvalue);

EXTERN int asn1JsonDec_LongitudeDMS2 (OSCTXT *pctxt, ASN1T_LongitudeDMS2 *pvalue);

EXTERN int asn1PrtToStrm_LongitudeDMS2 (OSCTXT *pctxt, 
   const char* name, const ASN1T_LongitudeDMS2* pvalue);

EXTERN ASN1T_LongitudeDMS2* new_ASN1T_LongitudeDMS2 (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Node_LLdms_48b                                            */
/*                                                            */
/**************************************************************/
/*
Node-LLdms-48b ::= SEQUENCE {
   lon [0] LongitudeDMS,
   lat [1] LatitudeDMS
}
*/
struct EXTERN ASN1T_Node_LLdms_48b {
   ASN1T_LongitudeDMS lon;
   ASN1T_LatitudeDMS lat;
} ;

EXTERN int asn1PE_Node_LLdms_48b (OSCTXT* pctxt, ASN1T_Node_LLdms_48b* pvalue);

EXTERN int asn1PD_Node_LLdms_48b (OSCTXT* pctxt, ASN1T_Node_LLdms_48b* pvalue);

EXTERN int XmlEnc_Node_LLdms_48b (OSCTXT* pctxt, ASN1T_Node_LLdms_48b* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Node_LLdms_48b (OSCTXT* pctxt, ASN1T_Node_LLdms_48b* pvalue)
   ;

EXTERN int asn1JsonEnc_Node_LLdms_48b (OSCTXT *pctxt, ASN1T_Node_LLdms_48b *pvalue);

EXTERN int asn1JsonDec_Node_LLdms_48b (OSCTXT *pctxt, ASN1T_Node_LLdms_48b *pvalue);

EXTERN int asn1PrtToStrm_Node_LLdms_48b (OSCTXT *pctxt, 
   const char* name, const ASN1T_Node_LLdms_48b* pvalue);

EXTERN ASN1T_Node_LLdms_48b* new_ASN1T_Node_LLdms_48b (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  Node_LLdms_80b                                            */
/*                                                            */
/**************************************************************/
/*
Node-LLdms-80b ::= SEQUENCE {
   lon [0] LongitudeDMS2,
   lat [1] LatitudeDMS2
}
*/
struct EXTERN ASN1T_Node_LLdms_80b {
   ASN1T_LongitudeDMS2 lon;
   ASN1T_LatitudeDMS2 lat;
} ;

EXTERN int asn1PE_Node_LLdms_80b (OSCTXT* pctxt, ASN1T_Node_LLdms_80b* pvalue);

EXTERN int asn1PD_Node_LLdms_80b (OSCTXT* pctxt, ASN1T_Node_LLdms_80b* pvalue);

EXTERN int XmlEnc_Node_LLdms_80b (OSCTXT* pctxt, ASN1T_Node_LLdms_80b* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Node_LLdms_80b (OSCTXT* pctxt, ASN1T_Node_LLdms_80b* pvalue)
   ;

EXTERN int asn1JsonEnc_Node_LLdms_80b (OSCTXT *pctxt, ASN1T_Node_LLdms_80b *pvalue);

EXTERN int asn1JsonDec_Node_LLdms_80b (OSCTXT *pctxt, ASN1T_Node_LLdms_80b *pvalue);

EXTERN int asn1PrtToStrm_Node_LLdms_80b (OSCTXT *pctxt, 
   const char* name, const ASN1T_Node_LLdms_80b* pvalue);

EXTERN ASN1T_Node_LLdms_80b* new_ASN1T_Node_LLdms_80b (ASN1CType& ccobj);

/**************************************************************/
/*                                                            */
/*  LaneDataAttribute_addGrpB                                 */
/*                                                            */
/**************************************************************/
/*
LaneDataAttribute-addGrpB ::= SEQUENCE {

   ...
}
*/
struct EXTERN ASN1T_LaneDataAttribute_addGrpB {
   ASN1TSeqExt extElem1;
} ;

EXTERN int asn1PE_LaneDataAttribute_addGrpB (OSCTXT* pctxt, ASN1T_LaneDataAttribute_addGrpB* pvalue);

EXTERN int asn1PD_LaneDataAttribute_addGrpB (OSCTXT* pctxt, ASN1T_LaneDataAttribute_addGrpB* pvalue);

EXTERN int XmlEnc_LaneDataAttribute_addGrpB (OSCTXT* pctxt, 
   ASN1T_LaneDataAttribute_addGrpB* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_LaneDataAttribute_addGrpB (OSCTXT* pctxt, 
   ASN1T_LaneDataAttribute_addGrpB* pvalue);

EXTERN int asn1JsonEnc_LaneDataAttribute_addGrpB (OSCTXT *pctxt, ASN1T_LaneDataAttribute_addGrpB *pvalue);

EXTERN int asn1JsonDec_LaneDataAttribute_addGrpB (OSCTXT *pctxt, ASN1T_LaneDataAttribute_addGrpB *pvalue);

EXTERN int asn1PrtToStrm_LaneDataAttribute_addGrpB (OSCTXT *pctxt, 
   const char* name, const ASN1T_LaneDataAttribute_addGrpB* pvalue);

EXTERN ASN1T_LaneDataAttribute_addGrpB* 
   new_ASN1T_LaneDataAttribute_addGrpB (ASN1CType& ccobj);

EXTERN int asn1Init_LaneDataAttribute_addGrpB (
   ASN1T_LaneDataAttribute_addGrpB* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_LaneDataAttribute_addGrpB (OSCTXT *pctxt, 
   ASN1T_LaneDataAttribute_addGrpB* pvalue);

/**************************************************************/
/*                                                            */
/*  MovementEvent_addGrpB                                     */
/*                                                            */
/**************************************************************/
/*
MovementEvent-addGrpB ::= SEQUENCE {
   -- A set of countdown style time-to-change values
   -- all in units of 0.1 seconds and following
   -- the naming of the base V2X standard
   startTime [0] TimeRemaining OPTIONAL,
               -- When this phase 1st started
   minEndTime [1] MinTimetoChange,
               -- Expected shortest end time
   maxEndTime [2] MaxTimetoChange OPTIONAL,
               -- Expected longest end time
   likelyTime [3] TimeRemaining OPTIONAL,
               -- Best predicted value based on other data             
   confidence [4] TimeIntervalConfidence OPTIONAL,
               -- Applies to above time element only
   nextTime [5] TimeRemaining OPTIONAL,
   ...
}
*/
struct EXTERN ASN1T_MovementEvent_addGrpB {
   struct {
      unsigned startTimePresent : 1;
      unsigned maxEndTimePresent : 1;
      unsigned likelyTimePresent : 1;
      unsigned confidencePresent : 1;
      unsigned nextTimePresent : 1;
   } m;
   ASN1T_TimeRemaining startTime;
   ASN1T_MinTimetoChange minEndTime;
   ASN1T_MaxTimetoChange maxEndTime;
   ASN1T_TimeRemaining likelyTime;
   OSUINT8 confidence;
   ASN1T_TimeRemaining nextTime;
   ASN1TSeqExt extElem1;
   ASN1T_MovementEvent_addGrpB ();
} ;

EXTERN int asn1PE_MovementEvent_addGrpB (OSCTXT* pctxt, ASN1T_MovementEvent_addGrpB* pvalue);

EXTERN int asn1PD_MovementEvent_addGrpB (OSCTXT* pctxt, ASN1T_MovementEvent_addGrpB* pvalue);

EXTERN int XmlEnc_MovementEvent_addGrpB (OSCTXT* pctxt, 
   ASN1T_MovementEvent_addGrpB* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_MovementEvent_addGrpB (OSCTXT* pctxt, 
   ASN1T_MovementEvent_addGrpB* pvalue);

EXTERN int asn1JsonEnc_MovementEvent_addGrpB (OSCTXT *pctxt, ASN1T_MovementEvent_addGrpB *pvalue);

EXTERN int asn1JsonDec_MovementEvent_addGrpB (OSCTXT *pctxt, ASN1T_MovementEvent_addGrpB *pvalue);

EXTERN int asn1PrtToStrm_MovementEvent_addGrpB (OSCTXT *pctxt, 
   const char* name, const ASN1T_MovementEvent_addGrpB* pvalue);

EXTERN ASN1T_MovementEvent_addGrpB* 
   new_ASN1T_MovementEvent_addGrpB (ASN1CType& ccobj);

EXTERN int asn1Init_MovementEvent_addGrpB (ASN1T_MovementEvent_addGrpB* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_MovementEvent_addGrpB (OSCTXT *pctxt, 
   ASN1T_MovementEvent_addGrpB* pvalue);

/**************************************************************/
/*                                                            */
/*  NodeOffsetPointXY_addGrpB                                 */
/*                                                            */
/**************************************************************/
/*
NodeOffsetPointXY-addGrpB ::= CHOICE {
   -- Full position expressed in units of 0.01 seconds
   posA [0] Node-LLdms-48b,
   -- Full position expressed in multiple elements in
   -- an DD.MM.SS.sss style format
   posB [1] Node-LLdms-80b,
   ...
}
*/
/* Choice tag constants */

#define T_NodeOffsetPointXY_addGrpB_posA 1
#define T_NodeOffsetPointXY_addGrpB_posB 2
#define T_NodeOffsetPointXY_addGrpB_extElem1 3

struct EXTERN ASN1T_NodeOffsetPointXY_addGrpB {
   OSINT32 t;
   union {
      /* t = 1 */
      ASN1T_Node_LLdms_48b *posA;
      /* t = 2 */
      ASN1T_Node_LLdms_80b *posB;
      /* t = 3 */
      ASN1TOpenType *extElem1;
   } u;
   ASN1T_NodeOffsetPointXY_addGrpB () { t = 0; OSCRTLMEMSET (&u, 0, sizeof(u)); }
} ;

EXTERN int asn1PE_NodeOffsetPointXY_addGrpB (OSCTXT* pctxt, ASN1T_NodeOffsetPointXY_addGrpB* pvalue);

EXTERN int asn1PD_NodeOffsetPointXY_addGrpB (OSCTXT* pctxt, ASN1T_NodeOffsetPointXY_addGrpB* pvalue);

EXTERN int XmlEnc_NodeOffsetPointXY_addGrpB (OSCTXT* pctxt, 
   ASN1T_NodeOffsetPointXY_addGrpB* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_NodeOffsetPointXY_addGrpB (OSCTXT* pctxt, 
   ASN1T_NodeOffsetPointXY_addGrpB* pvalue);

EXTERN int asn1JsonEnc_NodeOffsetPointXY_addGrpB (OSCTXT *pctxt, ASN1T_NodeOffsetPointXY_addGrpB *pvalue);

EXTERN int asn1JsonDec_NodeOffsetPointXY_addGrpB (OSCTXT *pctxt, ASN1T_NodeOffsetPointXY_addGrpB *pvalue);

EXTERN int asn1PrtToStrm_NodeOffsetPointXY_addGrpB (OSCTXT *pctxt, 
   const char* name, const ASN1T_NodeOffsetPointXY_addGrpB* pvalue);

EXTERN ASN1T_NodeOffsetPointXY_addGrpB* 
   new_ASN1T_NodeOffsetPointXY_addGrpB (ASN1CType& ccobj);

EXTERN int asn1Init_NodeOffsetPointXY_addGrpB (
   ASN1T_NodeOffsetPointXY_addGrpB* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_NodeOffsetPointXY_addGrpB (OSCTXT *pctxt, 
   ASN1T_NodeOffsetPointXY_addGrpB* pvalue);

/**************************************************************/
/*                                                            */
/*  Position3D_addGrpB                                        */
/*                                                            */
/**************************************************************/
/*
Position3D-addGrpB ::= SEQUENCE {
   latitude [0] LatitudeDMS2,
   longitude [1] LongitudeDMS2,
   elevation [2] Elevation,
   ...
}
*/
struct EXTERN ASN1T_Position3D_addGrpB {
   ASN1T_LatitudeDMS2 latitude;
   ASN1T_LongitudeDMS2 longitude;
   ASN1T_Elevation elevation;
   ASN1TSeqExt extElem1;
} ;

EXTERN int asn1PE_Position3D_addGrpB (OSCTXT* pctxt, ASN1T_Position3D_addGrpB* pvalue);

EXTERN int asn1PD_Position3D_addGrpB (OSCTXT* pctxt, ASN1T_Position3D_addGrpB* pvalue);

EXTERN int XmlEnc_Position3D_addGrpB (OSCTXT* pctxt, 
   ASN1T_Position3D_addGrpB* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_Position3D_addGrpB (OSCTXT* pctxt, 
   ASN1T_Position3D_addGrpB* pvalue);

EXTERN int asn1JsonEnc_Position3D_addGrpB (OSCTXT *pctxt, ASN1T_Position3D_addGrpB *pvalue);

EXTERN int asn1JsonDec_Position3D_addGrpB (OSCTXT *pctxt, ASN1T_Position3D_addGrpB *pvalue);

EXTERN int asn1PrtToStrm_Position3D_addGrpB (OSCTXT *pctxt, 
   const char* name, const ASN1T_Position3D_addGrpB* pvalue);

EXTERN ASN1T_Position3D_addGrpB* 
   new_ASN1T_Position3D_addGrpB (ASN1CType& ccobj);

EXTERN int asn1Init_Position3D_addGrpB (ASN1T_Position3D_addGrpB* pvalue, 
   OSBOOL free = FALSE, OSCTXT *pctxt = 0);

EXTERN void asn1Free_Position3D_addGrpB (OSCTXT *pctxt, 
   ASN1T_Position3D_addGrpB* pvalue);

/**************************************************************/
/*                                                            */
/*  TimeMark                                                  */
/*                                                            */
/**************************************************************/
/*
TimeMark ::= SEQUENCE {
   year [0] Year, -- BCD coding of A.D.    2 octets
   month [1] Month, -- BCD coding of Month,  1 octet
   day [2] Day, -- BCD coding of Day,    1 octet
   summerTime [3] SummerTime,
   holiday [4] Holiday,
   dayofWeek [5] DayOfWeek,
   hour [6] Hour, -- BCD coding of Hour,   1 octet
   minute [7] Minute, -- BCD coding of Minute, 1 octet
   second [8] Second, -- BCD coding of Second, 1 octet
   tenthSecond [9] TenthSecond -- units of 100 millisecond, 1 octet
}
*/
struct EXTERN ASN1T_TimeMark : public ASN1TPDU {
   ASN1T_Year year;
   ASN1T_Month month;
   ASN1T_Day day;
   ASN1T_SummerTime summerTime;
   ASN1T_Holiday holiday;
   ASN1T_DayOfWeek dayofWeek;
   ASN1T_Hour hour;
   ASN1T_Minute minute;
   ASN1T_Second second;
   ASN1T_TenthSecond tenthSecond;
} ;

class EXTERN ASN1C_TimeMark :
public ASN1CType
{
protected:
   ASN1T_TimeMark& msgData;
public:
   /**
    * Control class: ASN1C_TimeMark
    * Data class:    ASN1T_TimeMark
    *
    * Constructs an instance of the control class given an instance of
    * the data class.
    *
    * WARNING: this creates an internal context to use for memory
    * allocations which will be deleted when the object goes out of
    * scope. This object must be used in the same method in which the
    * data class object is being used.
    *
    * @param data    A reference to an instance of the data class.
    */
   ASN1C_TimeMark (ASN1T_TimeMark& data);

   /**
    * Control class: ASN1C_TimeMark<br/>
    * Data class: ASN1T_TimeMark<br/>
    *
    * Constructs an instance of the control class given an instance
    * of an encode or decode buffer and an instance of
    * the data class.
    *
    * @param msgBuf Reference to an instance of an encode or
    *                  decode buffer.
    * @param data   Reference to an instance of the data class.
    */
   ASN1C_TimeMark (OSRTMessageBufferIF& msgBuf, ASN1T_TimeMark& data);

   virtual ~ASN1C_TimeMark () {}

   /**
    * Data class: ASN1T_TimeMark<br/>
    *
    * Gets a mutable instance of the data class.
    *
    * @return Reference to a mutable instance of data class ASN1T_TimeMark.
    */
   inline ASN1T_TimeMark& getData () { return msgData; }

   /**
    * Data class: ASN1T_TimeMark<br/>
    * Gets a non-mutable instance of the data class.
    *
    * @return Reference to a non-mutable instance of data class ASN1T_TimeMark.
    */
   inline const ASN1T_TimeMark& getData () const { return msgData; }

   // standard encode/decode methods (defined in ASN1CType base class):
   // int Encode ();
   // int Decode ();

   // stream encode/decode methods:
   /**
    * Encodes into a specified encode buffer.
    *
    * @param msgBuf Reference to an encode buffer.
    * @return A status value (0 indicates success).
    */
   int EncodeTo (OSRTMessageBufferIF& msgBuf);

   /**
    * Decodes from a specified decode buffer.
    *
    * @param msgBuf Reference to a decode buffer.
    * @return A status value (0 indicates success).
    */
   int DecodeFrom (OSRTMessageBufferIF& msgBuf, OSBOOL free = FALSE);

   /**
    * Writes the contents of the object to a user-defined stream using
    * a user-defined print callback function.  See the documentation for
    * the setPrintStream() method.
    *
    * @param name A name for the object's contents.  If not specified,
    *             TimeMark will be used for the name.
    * @return Always returns 0.
    */
   int toStream (const char* name = "TimeMark");
   /**
    * Declares a print stream handler function.
    *
    * @param strmCallback Pointer to a function defined according to the
    *                     rtxPrintCallback signature.
    * @return A status value (0 indicates success).
    */
   int setPrintStream (rtxPrintCallback strmCallback, void* pStrmInfo);
private:
   ASN1C_TimeMark& operator= (const ASN1C_TimeMark&) {return *this;}
} ;

EXTERN int asn1PE_TimeMark (OSCTXT* pctxt, ASN1T_TimeMark* pvalue);

EXTERN int asn1PD_TimeMark (OSCTXT* pctxt, ASN1T_TimeMark* pvalue);

EXTERN int XmlEnc_TimeMark (OSCTXT* pctxt, ASN1T_TimeMark* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix);

EXTERN int XmlDec_TimeMark (OSCTXT* pctxt, ASN1T_TimeMark* pvalue);

EXTERN int asn1JsonEnc_TimeMark (OSCTXT *pctxt, ASN1T_TimeMark *pvalue);

EXTERN int asn1JsonDec_TimeMark (OSCTXT *pctxt, ASN1T_TimeMark *pvalue);

EXTERN int asn1PrtToStrm_TimeMark (OSCTXT *pctxt, 
   const char* name, const ASN1T_TimeMark* pvalue);

EXTERN ASN1T_TimeMark* new_ASN1T_TimeMark (ASN1CType& ccobj);

/**
 * Global element functions.  These functions encode or decode complete
 * XML documents.  They are generated for XSD global elements and/or
 * ASN.1 type definitions that are either:
 *
 * 1) not referenced by any other types, or
 * 2) explicitly declared to be a PDU using the -pdu command line
 *    option, or
 * 3) explicitly declared to be a PDU using the <isPDU/> 
 *    configuration file element.
 */
#endif
